// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kcers-survey/biz/dal/db/mysql/ent/api"
	"kcers-survey/biz/dal/db/mysql/ent/dictionary"
	"kcers-survey/biz/dal/db/mysql/ent/dictionarydetail"
	"kcers-survey/biz/dal/db/mysql/ent/logs"
	"kcers-survey/biz/dal/db/mysql/ent/menu"
	"kcers-survey/biz/dal/db/mysql/ent/menuparam"
	"kcers-survey/biz/dal/db/mysql/ent/predicate"
	"kcers-survey/biz/dal/db/mysql/ent/role"
	"kcers-survey/biz/dal/db/mysql/ent/survey"
	"kcers-survey/biz/dal/db/mysql/ent/surveyquestion"
	"kcers-survey/biz/dal/db/mysql/ent/surveyquestionoptions"
	"kcers-survey/biz/dal/db/mysql/ent/surveyresponse"
	"kcers-survey/biz/dal/db/mysql/ent/surveyresponseanswers"
	"kcers-survey/biz/dal/db/mysql/ent/token"
	"kcers-survey/biz/dal/db/mysql/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                   = "API"
	TypeDictionary            = "Dictionary"
	TypeDictionaryDetail      = "DictionaryDetail"
	TypeLogs                  = "Logs"
	TypeMenu                  = "Menu"
	TypeMenuParam             = "MenuParam"
	TypeRole                  = "Role"
	TypeSurvey                = "Survey"
	TypeSurveyQuestion        = "SurveyQuestion"
	TypeSurveyQuestionOptions = "SurveyQuestionOptions"
	TypeSurveyResponse        = "SurveyResponse"
	TypeSurveyResponseAnswers = "SurveyResponseAnswers"
	TypeToken                 = "Token"
	TypeUser                  = "User"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_path         *string
	title         *string
	description   *string
	api_group     *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APIMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[api.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APIMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, api.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *APIMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[api.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *APIMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, api.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *APIMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *APIMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *APIMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *APIMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *APIMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[api.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *APIMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[api.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *APIMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, api.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *APIMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *APIMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *APIMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *APIMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *APIMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[api.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *APIMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *APIMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, api.FieldCreatedID)
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetTitle sets the "title" field.
func (m *APIMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *APIMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *APIMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.title != nil {
		fields = append(fields, api.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldDelete:
		return m.Delete()
	case api.FieldCreatedID:
		return m.CreatedID()
	case api.FieldPath:
		return m.Path()
	case api.FieldTitle:
		return m.Title()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldDelete:
		return m.OldDelete(ctx)
	case api.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldTitle:
		return m.OldTitle(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldDelete:
		return m.AddedDelete()
	case api.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldCreatedAt) {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.FieldCleared(api.FieldUpdatedAt) {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.FieldCleared(api.FieldDelete) {
		fields = append(fields, api.FieldDelete)
	}
	if m.FieldCleared(api.FieldCreatedID) {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ClearDelete()
		return nil
	case api.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ResetDelete()
		return nil
	case api.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldTitle:
		m.ResetTitle()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_at                *time.Time
	updated_at                *time.Time
	delete                    *int64
	adddelete                 *int64
	created_id                *int64
	addcreated_id             *int64
	status                    *int64
	addstatus                 *int64
	title                     *string
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	dictionary_details        map[int64]struct{}
	removeddictionary_details map[int64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictionaryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictionary.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictionary.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictionaryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictionary.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictionaryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictionary.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictionaryMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictionaryMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictionaryMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictionaryMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictionaryMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictionary.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictionaryMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictionaryMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictionary.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictionaryMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictionaryMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictionaryMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictionaryMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictionaryMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictionary.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictionaryMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictionary.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DictionaryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictionaryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictionaryMutation) ResetDescription() {
	m.description = nil
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...int64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...int64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []int64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []int64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dictionary.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldDelete:
		return m.Delete()
	case dictionary.FieldCreatedID:
		return m.CreatedID()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldDelete:
		return m.OldDelete(ctx)
	case dictionary.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictionary.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldDelete:
		return m.AddedDelete()
	case dictionary.FieldCreatedID:
		return m.AddedCreatedID()
	case dictionary.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictionary.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldCreatedAt) {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.FieldCleared(dictionary.FieldUpdatedAt) {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.FieldCleared(dictionary.FieldDelete) {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.FieldCleared(dictionary.FieldCreatedID) {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictionary.FieldDelete:
		m.ClearDelete()
		return nil
	case dictionary.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldDelete:
		m.ResetDelete()
		return nil
	case dictionary.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	delete            *int64
	adddelete         *int64
	created_id        *int64
	addcreated_id     *int64
	status            *int64
	addstatus         *int64
	title             *string
	key               *string
	value             *string
	clearedFields     map[string]struct{}
	dictionary        *int64
	cleareddictionary bool
	done              bool
	oldValue          func(context.Context) (*DictionaryDetail, error)
	predicates        []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id int64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictionaryDetailMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictionarydetail.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictionarydetail.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictionaryDetailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictionarydetail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictionaryDetailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictionarydetail.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictionaryDetailMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictionaryDetailMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictionaryDetailMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictionaryDetailMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictionaryDetailMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictionarydetail.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictionaryDetailMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictionarydetail.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictionaryDetailMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictionaryDetailMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictionaryDetailMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictionaryDetailMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictionaryDetailMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictionarydetail.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictionaryDetailMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictionarydetail.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetKey sets the "key" field.
func (m *DictionaryDetailMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryDetailMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryDetailMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(i int64) {
	m.dictionary = &i
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r int64, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionary = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionary = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionaryCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionaryIDs() (ids []int64) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryDetailMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.key != nil {
		fields = append(fields, dictionarydetail.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldDelete:
		return m.Delete()
	case dictionarydetail.FieldCreatedID:
		return m.CreatedID()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldKey:
		return m.Key()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldDelete:
		return m.OldDelete(ctx)
	case dictionarydetail.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldKey:
		return m.OldKey(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictionarydetail.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldDelete:
		return m.AddedDelete()
	case dictionarydetail.FieldCreatedID:
		return m.AddedCreatedID()
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictionarydetail.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldCreatedAt) {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.FieldCleared(dictionarydetail.FieldUpdatedAt) {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.FieldCleared(dictionarydetail.FieldDelete) {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.FieldCleared(dictionarydetail.FieldCreatedID) {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictionarydetail.FieldDelete:
		m.ClearDelete()
		return nil
	case dictionarydetail.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldDelete:
		m.ResetDelete()
		return nil
	case dictionarydetail.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldKey:
		m.ResetKey()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary != nil {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionary:
		return m.cleareddictionary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ResetDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operatorsr    *string
	time          *int64
	addtime       *int64
	identity      *int64
	addidentity   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[logs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, logs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[logs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, logs.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *LogsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *LogsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *LogsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *LogsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *LogsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[logs.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *LogsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[logs.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *LogsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, logs.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *LogsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *LogsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *LogsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *LogsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *LogsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[logs.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *LogsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *LogsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, logs.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperatorsr sets the "operatorsr" field.
func (m *LogsMutation) SetOperatorsr(s string) {
	m.operatorsr = &s
}

// Operatorsr returns the value of the "operatorsr" field in the mutation.
func (m *LogsMutation) Operatorsr() (r string, exists bool) {
	v := m.operatorsr
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorsr returns the old "operatorsr" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperatorsr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorsr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorsr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorsr: %w", err)
	}
	return oldValue.Operatorsr, nil
}

// ClearOperatorsr clears the value of the "operatorsr" field.
func (m *LogsMutation) ClearOperatorsr() {
	m.operatorsr = nil
	m.clearedFields[logs.FieldOperatorsr] = struct{}{}
}

// OperatorsrCleared returns if the "operatorsr" field was cleared in this mutation.
func (m *LogsMutation) OperatorsrCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperatorsr]
	return ok
}

// ResetOperatorsr resets all changes to the "operatorsr" field.
func (m *LogsMutation) ResetOperatorsr() {
	m.operatorsr = nil
	delete(m.clearedFields, logs.FieldOperatorsr)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int64) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int64, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int64) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int64, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// SetIdentity sets the "identity" field.
func (m *LogsMutation) SetIdentity(i int64) {
	m.identity = &i
	m.addidentity = nil
}

// Identity returns the value of the "identity" field in the mutation.
func (m *LogsMutation) Identity() (r int64, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIdentity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// AddIdentity adds i to the "identity" field.
func (m *LogsMutation) AddIdentity(i int64) {
	if m.addidentity != nil {
		*m.addidentity += i
	} else {
		m.addidentity = &i
	}
}

// AddedIdentity returns the value that was added to the "identity" field in this mutation.
func (m *LogsMutation) AddedIdentity() (r int64, exists bool) {
	v := m.addidentity
	if v == nil {
		return
	}
	return *v, true
}

// ClearIdentity clears the value of the "identity" field.
func (m *LogsMutation) ClearIdentity() {
	m.identity = nil
	m.addidentity = nil
	m.clearedFields[logs.FieldIdentity] = struct{}{}
}

// IdentityCleared returns if the "identity" field was cleared in this mutation.
func (m *LogsMutation) IdentityCleared() bool {
	_, ok := m.clearedFields[logs.FieldIdentity]
	return ok
}

// ResetIdentity resets all changes to the "identity" field.
func (m *LogsMutation) ResetIdentity() {
	m.identity = nil
	m.addidentity = nil
	delete(m.clearedFields, logs.FieldIdentity)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operatorsr != nil {
		fields = append(fields, logs.FieldOperatorsr)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	if m.identity != nil {
		fields = append(fields, logs.FieldIdentity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldDelete:
		return m.Delete()
	case logs.FieldCreatedID:
		return m.CreatedID()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperatorsr:
		return m.Operatorsr()
	case logs.FieldTime:
		return m.Time()
	case logs.FieldIdentity:
		return m.Identity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldDelete:
		return m.OldDelete(ctx)
	case logs.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperatorsr:
		return m.OldOperatorsr(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	case logs.FieldIdentity:
		return m.OldIdentity(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperatorsr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorsr(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case logs.FieldIdentity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	if m.addidentity != nil {
		fields = append(fields, logs.FieldIdentity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldDelete:
		return m.AddedDelete()
	case logs.FieldCreatedID:
		return m.AddedCreatedID()
	case logs.FieldTime:
		return m.AddedTime()
	case logs.FieldIdentity:
		return m.AddedIdentity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	case logs.FieldIdentity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdentity(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldCreatedAt) {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.FieldCleared(logs.FieldUpdatedAt) {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.FieldCleared(logs.FieldDelete) {
		fields = append(fields, logs.FieldDelete)
	}
	if m.FieldCleared(logs.FieldCreatedID) {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperatorsr) {
		fields = append(fields, logs.FieldOperatorsr)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	if m.FieldCleared(logs.FieldIdentity) {
		fields = append(fields, logs.FieldIdentity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ClearDelete()
		return nil
	case logs.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperatorsr:
		m.ClearOperatorsr()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	case logs.FieldIdentity:
		m.ClearIdentity()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ResetDelete()
		return nil
	case logs.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperatorsr:
		m.ResetOperatorsr()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	case logs.FieldIdentity:
		m.ResetIdentity()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	_path           *string
	name            *string
	order_no        *int64
	addorder_no     *int64
	disabled        *int64
	adddisabled     *int64
	ignore          *bool
	clearedFields   map[string]struct{}
	roles           map[int64]struct{}
	removedroles    map[int64]struct{}
	clearedroles    bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	params          map[int64]struct{}
	removedparams   map[int64]struct{}
	clearedparams   bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menu.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menu.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menu.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menu.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menu.FieldCreatedID)
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetOrderNo sets the "order_no" field.
func (m *MenuMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *MenuMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *MenuMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *MenuMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *MenuMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(i int64) {
	m.disabled = &i
	m.adddisabled = nil
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r int64, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// AddDisabled adds i to the "disabled" field.
func (m *MenuMutation) AddDisabled(i int64) {
	if m.adddisabled != nil {
		*m.adddisabled += i
	} else {
		m.adddisabled = &i
	}
}

// AddedDisabled returns the value that was added to the "disabled" field in this mutation.
func (m *MenuMutation) AddedDisabled() (r int64, exists bool) {
	v := m.adddisabled
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// SetIgnore sets the "ignore" field.
func (m *MenuMutation) SetIgnore(b bool) {
	m.ignore = &b
}

// Ignore returns the value of the "ignore" field in the mutation.
func (m *MenuMutation) Ignore() (r bool, exists bool) {
	v := m.ignore
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnore returns the old "ignore" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnore(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnore: %w", err)
	}
	return oldValue.Ignore, nil
}

// ClearIgnore clears the value of the "ignore" field.
func (m *MenuMutation) ClearIgnore() {
	m.ignore = nil
	m.clearedFields[menu.FieldIgnore] = struct{}{}
}

// IgnoreCleared returns if the "ignore" field was cleared in this mutation.
func (m *MenuMutation) IgnoreCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnore]
	return ok
}

// ResetIgnore resets all changes to the "ignore" field.
func (m *MenuMutation) ResetIgnore() {
	m.ignore = nil
	delete(m.clearedFields, menu.FieldIgnore)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParamIDs adds the "params" edge to the MenuParam entity by ids.
func (m *MenuMutation) AddParamIDs(ids ...int64) {
	if m.params == nil {
		m.params = make(map[int64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the MenuParam entity.
func (m *MenuMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the MenuParam entity was cleared.
func (m *MenuMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the MenuParam entity by IDs.
func (m *MenuMutation) RemoveParamIDs(ids ...int64) {
	if m.removedparams == nil {
		m.removedparams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the MenuParam entity.
func (m *MenuMutation) RemovedParamsIDs() (ids []int64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *MenuMutation) ParamsIDs() (ids []int64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.order_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.ignore != nil {
		fields = append(fields, menu.FieldIgnore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldDelete:
		return m.Delete()
	case menu.FieldCreatedID:
		return m.CreatedID()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldOrderNo:
		return m.OrderNo()
	case menu.FieldDisabled:
		return m.Disabled()
	case menu.FieldIgnore:
		return m.Ignore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldDelete:
		return m.OldDelete(ctx)
	case menu.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	case menu.FieldIgnore:
		return m.OldIgnore(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case menu.FieldIgnore:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnore(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.addorder_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.adddisabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldDelete:
		return m.AddedDelete()
	case menu.FieldCreatedID:
		return m.AddedCreatedID()
	case menu.FieldOrderNo:
		return m.AddedOrderNo()
	case menu.FieldDisabled:
		return m.AddedDisabled()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreatedAt) {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.FieldCleared(menu.FieldDelete) {
		fields = append(fields, menu.FieldDelete)
	}
	if m.FieldCleared(menu.FieldCreatedID) {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.FieldCleared(menu.FieldIgnore) {
		fields = append(fields, menu.FieldIgnore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ClearDelete()
		return nil
	case menu.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	case menu.FieldIgnore:
		m.ClearIgnore()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ResetDelete()
		return nil
	case menu.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	case menu.FieldIgnore:
		m.ResetIgnore()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.params != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedparams != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedparams {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuParamMutation represents an operation that mutates the MenuParam nodes in the graph.
type MenuParamMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	menus         *int64
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*MenuParam, error)
	predicates    []predicate.MenuParam
}

var _ ent.Mutation = (*MenuParamMutation)(nil)

// menuparamOption allows management of the mutation configuration using functional options.
type menuparamOption func(*MenuParamMutation)

// newMenuParamMutation creates new mutation for the MenuParam entity.
func newMenuParamMutation(c config, op Op, opts ...menuparamOption) *MenuParamMutation {
	m := &MenuParamMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuParamID sets the ID field of the mutation.
func withMenuParamID(id int64) menuparamOption {
	return func(m *MenuParamMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuParam
		)
		m.oldValue = func(ctx context.Context) (*MenuParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuParam sets the old MenuParam of the mutation.
func withMenuParam(node *MenuParam) menuparamOption {
	return func(m *MenuParamMutation) {
		m.oldValue = func(context.Context) (*MenuParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuParam entities.
func (m *MenuParamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuParamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuParamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuParamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menuparam.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuParamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuParamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menuparam.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuParamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menuparam.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuParamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menuparam.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuParamMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuParamMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuParamMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuParamMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuParamMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menuparam.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuParamMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuParamMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menuparam.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuParamMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuParamMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuParamMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuParamMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuParamMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menuparam.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuParamMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuParamMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menuparam.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *MenuParamMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuParamMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MenuParamMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *MenuParamMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MenuParamMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MenuParamMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *MenuParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MenuParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MenuParamMutation) ResetValue() {
	m.value = nil
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *MenuParamMutation) SetMenusID(id int64) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *MenuParamMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *MenuParamMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *MenuParamMutation) MenusID() (id int64, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *MenuParamMutation) MenusIDs() (ids []int64) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *MenuParamMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the MenuParamMutation builder.
func (m *MenuParamMutation) Where(ps ...predicate.MenuParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuParam).
func (m *MenuParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuParamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, menuparam.FieldType)
	}
	if m.key != nil {
		fields = append(fields, menuparam.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, menuparam.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.CreatedAt()
	case menuparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuparam.FieldDelete:
		return m.Delete()
	case menuparam.FieldCreatedID:
		return m.CreatedID()
	case menuparam.FieldType:
		return m.GetType()
	case menuparam.FieldKey:
		return m.Key()
	case menuparam.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuparam.FieldDelete:
		return m.OldDelete(ctx)
	case menuparam.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menuparam.FieldType:
		return m.OldType(ctx)
	case menuparam.FieldKey:
		return m.OldKey(ctx)
	case menuparam.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MenuParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuparam.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menuparam.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menuparam.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuparam.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case menuparam.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuParamMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuParamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldDelete:
		return m.AddedDelete()
	case menuparam.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menuparam.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuParamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menuparam.FieldCreatedAt) {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.FieldCleared(menuparam.FieldUpdatedAt) {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m.FieldCleared(menuparam.FieldDelete) {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.FieldCleared(menuparam.FieldCreatedID) {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuParamMutation) ClearField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menuparam.FieldDelete:
		m.ClearDelete()
		return nil
	case menuparam.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown MenuParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuParamMutation) ResetField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuparam.FieldDelete:
		m.ResetDelete()
		return nil
	case menuparam.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menuparam.FieldType:
		m.ResetType()
		return nil
	case menuparam.FieldKey:
		m.ResetKey()
		return nil
	case menuparam.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuparam.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuParamMutation) EdgeCleared(name string) bool {
	switch name {
	case menuparam.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuParamMutation) ClearEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuParamMutation) ResetEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	name           *string
	value          *string
	default_router *string
	remark         *string
	order_no       *int64
	addorder_no    *int64
	apis           *[]int
	appendapis     []int
	venue_id       *int64
	addvenue_id    *int64
	clearedFields  map[string]struct{}
	menus          map[int64]struct{}
	removedmenus   map[int64]struct{}
	clearedmenus   bool
	users          map[int64]struct{}
	removedusers   map[int64]struct{}
	clearedusers   bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[role.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, role.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *RoleMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *RoleMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *RoleMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *RoleMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *RoleMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[role.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *RoleMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[role.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *RoleMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, role.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *RoleMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *RoleMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *RoleMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *RoleMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *RoleMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[role.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *RoleMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *RoleMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, role.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RoleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RoleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RoleMutation) ResetValue() {
	m.value = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetApis sets the "apis" field.
func (m *RoleMutation) SetApis(i []int) {
	m.apis = &i
	m.appendapis = nil
}

// Apis returns the value of the "apis" field in the mutation.
func (m *RoleMutation) Apis() (r []int, exists bool) {
	v := m.apis
	if v == nil {
		return
	}
	return *v, true
}

// OldApis returns the old "apis" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApis(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApis: %w", err)
	}
	return oldValue.Apis, nil
}

// AppendApis adds i to the "apis" field.
func (m *RoleMutation) AppendApis(i []int) {
	m.appendapis = append(m.appendapis, i...)
}

// AppendedApis returns the list of values that were appended to the "apis" field in this mutation.
func (m *RoleMutation) AppendedApis() ([]int, bool) {
	if len(m.appendapis) == 0 {
		return nil, false
	}
	return m.appendapis, true
}

// ResetApis resets all changes to the "apis" field.
func (m *RoleMutation) ResetApis() {
	m.apis = nil
	m.appendapis = nil
}

// SetVenueID sets the "venue_id" field.
func (m *RoleMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *RoleMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *RoleMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *RoleMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *RoleMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.value != nil {
		fields = append(fields, role.FieldValue)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.apis != nil {
		fields = append(fields, role.FieldApis)
	}
	if m.venue_id != nil {
		fields = append(fields, role.FieldVenueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDelete:
		return m.Delete()
	case role.FieldCreatedID:
		return m.CreatedID()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldValue:
		return m.Value()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldOrderNo:
		return m.OrderNo()
	case role.FieldApis:
		return m.Apis()
	case role.FieldVenueID:
		return m.VenueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDelete:
		return m.OldDelete(ctx)
	case role.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldValue:
		return m.OldValue(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case role.FieldApis:
		return m.OldApis(ctx)
	case role.FieldVenueID:
		return m.OldVenueID(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case role.FieldApis:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApis(v)
		return nil
	case role.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.addvenue_id != nil {
		fields = append(fields, role.FieldVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDelete:
		return m.AddedDelete()
	case role.FieldCreatedID:
		return m.AddedCreatedID()
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	case role.FieldVenueID:
		return m.AddedVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case role.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedAt) {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDelete) {
		fields = append(fields, role.FieldDelete)
	}
	if m.FieldCleared(role.FieldCreatedID) {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ClearDelete()
		return nil
	case role.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ResetDelete()
		return nil
	case role.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldValue:
		m.ResetValue()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case role.FieldApis:
		m.ResetApis()
		return nil
	case role.FieldVenueID:
		m.ResetVenueID()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SurveyMutation represents an operation that mutates the Survey nodes in the graph.
type SurveyMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	title           *string
	pic             *string
	desc            *string
	start_at        *time.Time
	end_at          *time.Time
	clearedFields   map[string]struct{}
	question        map[int64]struct{}
	removedquestion map[int64]struct{}
	clearedquestion bool
	done            bool
	oldValue        func(context.Context) (*Survey, error)
	predicates      []predicate.Survey
}

var _ ent.Mutation = (*SurveyMutation)(nil)

// surveyOption allows management of the mutation configuration using functional options.
type surveyOption func(*SurveyMutation)

// newSurveyMutation creates new mutation for the Survey entity.
func newSurveyMutation(c config, op Op, opts ...surveyOption) *SurveyMutation {
	m := &SurveyMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyID sets the ID field of the mutation.
func withSurveyID(id int64) surveyOption {
	return func(m *SurveyMutation) {
		var (
			err   error
			once  sync.Once
			value *Survey
		)
		m.oldValue = func(ctx context.Context) (*Survey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Survey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurvey sets the old Survey of the mutation.
func withSurvey(node *Survey) surveyOption {
	return func(m *SurveyMutation) {
		m.oldValue = func(context.Context) (*Survey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Survey entities.
func (m *SurveyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Survey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SurveyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[survey.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SurveyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, survey.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SurveyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[survey.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SurveyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, survey.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SurveyMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SurveyMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SurveyMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SurveyMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SurveyMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[survey.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SurveyMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[survey.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SurveyMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, survey.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SurveyMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SurveyMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SurveyMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SurveyMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SurveyMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[survey.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SurveyMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[survey.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SurveyMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, survey.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SurveyMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SurveyMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SurveyMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SurveyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[survey.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SurveyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[survey.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, survey.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *SurveyMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SurveyMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *SurveyMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[survey.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *SurveyMutation) TitleCleared() bool {
	_, ok := m.clearedFields[survey.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *SurveyMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, survey.FieldTitle)
}

// SetPic sets the "pic" field.
func (m *SurveyMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *SurveyMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *SurveyMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[survey.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *SurveyMutation) PicCleared() bool {
	_, ok := m.clearedFields[survey.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *SurveyMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, survey.FieldPic)
}

// SetDesc sets the "desc" field.
func (m *SurveyMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *SurveyMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *SurveyMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[survey.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *SurveyMutation) DescCleared() bool {
	_, ok := m.clearedFields[survey.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *SurveyMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, survey.FieldDesc)
}

// SetStartAt sets the "start_at" field.
func (m *SurveyMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *SurveyMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *SurveyMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[survey.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *SurveyMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *SurveyMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, survey.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *SurveyMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *SurveyMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *SurveyMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[survey.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *SurveyMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *SurveyMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, survey.FieldEndAt)
}

// AddQuestionIDs adds the "question" edge to the SurveyQuestion entity by ids.
func (m *SurveyMutation) AddQuestionIDs(ids ...int64) {
	if m.question == nil {
		m.question = make(map[int64]struct{})
	}
	for i := range ids {
		m.question[ids[i]] = struct{}{}
	}
}

// ClearQuestion clears the "question" edge to the SurveyQuestion entity.
func (m *SurveyMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the SurveyQuestion entity was cleared.
func (m *SurveyMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// RemoveQuestionIDs removes the "question" edge to the SurveyQuestion entity by IDs.
func (m *SurveyMutation) RemoveQuestionIDs(ids ...int64) {
	if m.removedquestion == nil {
		m.removedquestion = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.question, ids[i])
		m.removedquestion[ids[i]] = struct{}{}
	}
}

// RemovedQuestion returns the removed IDs of the "question" edge to the SurveyQuestion entity.
func (m *SurveyMutation) RemovedQuestionIDs() (ids []int64) {
	for id := range m.removedquestion {
		ids = append(ids, id)
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
func (m *SurveyMutation) QuestionIDs() (ids []int64) {
	for id := range m.question {
		ids = append(ids, id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *SurveyMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
	m.removedquestion = nil
}

// Where appends a list predicates to the SurveyMutation builder.
func (m *SurveyMutation) Where(ps ...predicate.Survey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Survey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Survey).
func (m *SurveyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, survey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, survey.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, survey.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, survey.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, survey.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, survey.FieldTitle)
	}
	if m.pic != nil {
		fields = append(fields, survey.FieldPic)
	}
	if m.desc != nil {
		fields = append(fields, survey.FieldDesc)
	}
	if m.start_at != nil {
		fields = append(fields, survey.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, survey.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldCreatedAt:
		return m.CreatedAt()
	case survey.FieldUpdatedAt:
		return m.UpdatedAt()
	case survey.FieldDelete:
		return m.Delete()
	case survey.FieldCreatedID:
		return m.CreatedID()
	case survey.FieldStatus:
		return m.Status()
	case survey.FieldTitle:
		return m.Title()
	case survey.FieldPic:
		return m.Pic()
	case survey.FieldDesc:
		return m.Desc()
	case survey.FieldStartAt:
		return m.StartAt()
	case survey.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case survey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case survey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case survey.FieldDelete:
		return m.OldDelete(ctx)
	case survey.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case survey.FieldStatus:
		return m.OldStatus(ctx)
	case survey.FieldTitle:
		return m.OldTitle(ctx)
	case survey.FieldPic:
		return m.OldPic(ctx)
	case survey.FieldDesc:
		return m.OldDesc(ctx)
	case survey.FieldStartAt:
		return m.OldStartAt(ctx)
	case survey.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown Survey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case survey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case survey.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case survey.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case survey.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case survey.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case survey.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case survey.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case survey.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case survey.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, survey.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, survey.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, survey.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldDelete:
		return m.AddedDelete()
	case survey.FieldCreatedID:
		return m.AddedCreatedID()
	case survey.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case survey.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case survey.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case survey.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Survey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survey.FieldCreatedAt) {
		fields = append(fields, survey.FieldCreatedAt)
	}
	if m.FieldCleared(survey.FieldUpdatedAt) {
		fields = append(fields, survey.FieldUpdatedAt)
	}
	if m.FieldCleared(survey.FieldDelete) {
		fields = append(fields, survey.FieldDelete)
	}
	if m.FieldCleared(survey.FieldCreatedID) {
		fields = append(fields, survey.FieldCreatedID)
	}
	if m.FieldCleared(survey.FieldStatus) {
		fields = append(fields, survey.FieldStatus)
	}
	if m.FieldCleared(survey.FieldTitle) {
		fields = append(fields, survey.FieldTitle)
	}
	if m.FieldCleared(survey.FieldPic) {
		fields = append(fields, survey.FieldPic)
	}
	if m.FieldCleared(survey.FieldDesc) {
		fields = append(fields, survey.FieldDesc)
	}
	if m.FieldCleared(survey.FieldStartAt) {
		fields = append(fields, survey.FieldStartAt)
	}
	if m.FieldCleared(survey.FieldEndAt) {
		fields = append(fields, survey.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyMutation) ClearField(name string) error {
	switch name {
	case survey.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case survey.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case survey.FieldDelete:
		m.ClearDelete()
		return nil
	case survey.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case survey.FieldStatus:
		m.ClearStatus()
		return nil
	case survey.FieldTitle:
		m.ClearTitle()
		return nil
	case survey.FieldPic:
		m.ClearPic()
		return nil
	case survey.FieldDesc:
		m.ClearDesc()
		return nil
	case survey.FieldStartAt:
		m.ClearStartAt()
		return nil
	case survey.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown Survey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyMutation) ResetField(name string) error {
	switch name {
	case survey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case survey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case survey.FieldDelete:
		m.ResetDelete()
		return nil
	case survey.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case survey.FieldStatus:
		m.ResetStatus()
		return nil
	case survey.FieldTitle:
		m.ResetTitle()
		return nil
	case survey.FieldPic:
		m.ResetPic()
		return nil
	case survey.FieldDesc:
		m.ResetDesc()
		return nil
	case survey.FieldStartAt:
		m.ResetStartAt()
		return nil
	case survey.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question != nil {
		edges = append(edges, survey.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.question))
		for id := range m.question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedquestion != nil {
		edges = append(edges, survey.EdgeQuestion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.removedquestion))
		for id := range m.removedquestion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion {
		edges = append(edges, survey.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyMutation) EdgeCleared(name string) bool {
	switch name {
	case survey.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyMutation) ResetEdge(name string) error {
	switch name {
	case survey.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown Survey edge %s", name)
}

// SurveyQuestionMutation represents an operation that mutates the SurveyQuestion nodes in the graph.
type SurveyQuestionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	parent_id     *int64
	addparent_id  *int64
	content       *string
	_type         *string
	sort          *int64
	addsort       *int64
	required      *int64
	addrequired   *int64
	options       *map[string]string
	clearedFields map[string]struct{}
	option        map[int64]struct{}
	removedoption map[int64]struct{}
	clearedoption bool
	survey        *int64
	clearedsurvey bool
	done          bool
	oldValue      func(context.Context) (*SurveyQuestion, error)
	predicates    []predicate.SurveyQuestion
}

var _ ent.Mutation = (*SurveyQuestionMutation)(nil)

// surveyquestionOption allows management of the mutation configuration using functional options.
type surveyquestionOption func(*SurveyQuestionMutation)

// newSurveyQuestionMutation creates new mutation for the SurveyQuestion entity.
func newSurveyQuestionMutation(c config, op Op, opts ...surveyquestionOption) *SurveyQuestionMutation {
	m := &SurveyQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyQuestionID sets the ID field of the mutation.
func withSurveyQuestionID(id int64) surveyquestionOption {
	return func(m *SurveyQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyQuestion
		)
		m.oldValue = func(ctx context.Context) (*SurveyQuestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyQuestion sets the old SurveyQuestion of the mutation.
func withSurveyQuestion(node *SurveyQuestion) surveyquestionOption {
	return func(m *SurveyQuestionMutation) {
		m.oldValue = func(context.Context) (*SurveyQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyQuestion entities.
func (m *SurveyQuestionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyQuestionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyQuestionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyQuestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyQuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyQuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SurveyQuestionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[surveyquestion.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SurveyQuestionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyQuestionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, surveyquestion.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyQuestionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyQuestionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SurveyQuestionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[surveyquestion.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SurveyQuestionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyQuestionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, surveyquestion.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SurveyQuestionMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SurveyQuestionMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SurveyQuestionMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SurveyQuestionMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SurveyQuestionMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[surveyquestion.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SurveyQuestionMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SurveyQuestionMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, surveyquestion.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SurveyQuestionMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SurveyQuestionMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SurveyQuestionMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SurveyQuestionMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SurveyQuestionMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[surveyquestion.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SurveyQuestionMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SurveyQuestionMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, surveyquestion.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SurveyQuestionMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyQuestionMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SurveyQuestionMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SurveyQuestionMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SurveyQuestionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[surveyquestion.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SurveyQuestionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyQuestionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, surveyquestion.FieldStatus)
}

// SetSurveyID sets the "survey_id" field.
func (m *SurveyQuestionMutation) SetSurveyID(i int64) {
	m.survey = &i
}

// SurveyID returns the value of the "survey_id" field in the mutation.
func (m *SurveyQuestionMutation) SurveyID() (r int64, exists bool) {
	v := m.survey
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyID returns the old "survey_id" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldSurveyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyID: %w", err)
	}
	return oldValue.SurveyID, nil
}

// ClearSurveyID clears the value of the "survey_id" field.
func (m *SurveyQuestionMutation) ClearSurveyID() {
	m.survey = nil
	m.clearedFields[surveyquestion.FieldSurveyID] = struct{}{}
}

// SurveyIDCleared returns if the "survey_id" field was cleared in this mutation.
func (m *SurveyQuestionMutation) SurveyIDCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldSurveyID]
	return ok
}

// ResetSurveyID resets all changes to the "survey_id" field.
func (m *SurveyQuestionMutation) ResetSurveyID() {
	m.survey = nil
	delete(m.clearedFields, surveyquestion.FieldSurveyID)
}

// SetParentID sets the "parent_id" field.
func (m *SurveyQuestionMutation) SetParentID(i int64) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *SurveyQuestionMutation) ParentID() (r int64, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *SurveyQuestionMutation) AddParentID(i int64) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *SurveyQuestionMutation) AddedParentID() (r int64, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *SurveyQuestionMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[surveyquestion.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *SurveyQuestionMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *SurveyQuestionMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, surveyquestion.FieldParentID)
}

// SetContent sets the "content" field.
func (m *SurveyQuestionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SurveyQuestionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *SurveyQuestionMutation) ClearContent() {
	m.content = nil
	m.clearedFields[surveyquestion.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *SurveyQuestionMutation) ContentCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *SurveyQuestionMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, surveyquestion.FieldContent)
}

// SetType sets the "type" field.
func (m *SurveyQuestionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SurveyQuestionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *SurveyQuestionMutation) ClearType() {
	m._type = nil
	m.clearedFields[surveyquestion.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *SurveyQuestionMutation) TypeCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *SurveyQuestionMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, surveyquestion.FieldType)
}

// SetSort sets the "sort" field.
func (m *SurveyQuestionMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *SurveyQuestionMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *SurveyQuestionMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *SurveyQuestionMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *SurveyQuestionMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[surveyquestion.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *SurveyQuestionMutation) SortCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *SurveyQuestionMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, surveyquestion.FieldSort)
}

// SetRequired sets the "required" field.
func (m *SurveyQuestionMutation) SetRequired(i int64) {
	m.required = &i
	m.addrequired = nil
}

// Required returns the value of the "required" field in the mutation.
func (m *SurveyQuestionMutation) Required() (r int64, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldRequired(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// AddRequired adds i to the "required" field.
func (m *SurveyQuestionMutation) AddRequired(i int64) {
	if m.addrequired != nil {
		*m.addrequired += i
	} else {
		m.addrequired = &i
	}
}

// AddedRequired returns the value that was added to the "required" field in this mutation.
func (m *SurveyQuestionMutation) AddedRequired() (r int64, exists bool) {
	v := m.addrequired
	if v == nil {
		return
	}
	return *v, true
}

// ClearRequired clears the value of the "required" field.
func (m *SurveyQuestionMutation) ClearRequired() {
	m.required = nil
	m.addrequired = nil
	m.clearedFields[surveyquestion.FieldRequired] = struct{}{}
}

// RequiredCleared returns if the "required" field was cleared in this mutation.
func (m *SurveyQuestionMutation) RequiredCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldRequired]
	return ok
}

// ResetRequired resets all changes to the "required" field.
func (m *SurveyQuestionMutation) ResetRequired() {
	m.required = nil
	m.addrequired = nil
	delete(m.clearedFields, surveyquestion.FieldRequired)
}

// SetOptions sets the "options" field.
func (m *SurveyQuestionMutation) SetOptions(value map[string]string) {
	m.options = &value
}

// Options returns the value of the "options" field in the mutation.
func (m *SurveyQuestionMutation) Options() (r map[string]string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldOptions(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ClearOptions clears the value of the "options" field.
func (m *SurveyQuestionMutation) ClearOptions() {
	m.options = nil
	m.clearedFields[surveyquestion.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *SurveyQuestionMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *SurveyQuestionMutation) ResetOptions() {
	m.options = nil
	delete(m.clearedFields, surveyquestion.FieldOptions)
}

// AddOptionIDs adds the "option" edge to the SurveyQuestionOptions entity by ids.
func (m *SurveyQuestionMutation) AddOptionIDs(ids ...int64) {
	if m.option == nil {
		m.option = make(map[int64]struct{})
	}
	for i := range ids {
		m.option[ids[i]] = struct{}{}
	}
}

// ClearOption clears the "option" edge to the SurveyQuestionOptions entity.
func (m *SurveyQuestionMutation) ClearOption() {
	m.clearedoption = true
}

// OptionCleared reports if the "option" edge to the SurveyQuestionOptions entity was cleared.
func (m *SurveyQuestionMutation) OptionCleared() bool {
	return m.clearedoption
}

// RemoveOptionIDs removes the "option" edge to the SurveyQuestionOptions entity by IDs.
func (m *SurveyQuestionMutation) RemoveOptionIDs(ids ...int64) {
	if m.removedoption == nil {
		m.removedoption = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.option, ids[i])
		m.removedoption[ids[i]] = struct{}{}
	}
}

// RemovedOption returns the removed IDs of the "option" edge to the SurveyQuestionOptions entity.
func (m *SurveyQuestionMutation) RemovedOptionIDs() (ids []int64) {
	for id := range m.removedoption {
		ids = append(ids, id)
	}
	return
}

// OptionIDs returns the "option" edge IDs in the mutation.
func (m *SurveyQuestionMutation) OptionIDs() (ids []int64) {
	for id := range m.option {
		ids = append(ids, id)
	}
	return
}

// ResetOption resets all changes to the "option" edge.
func (m *SurveyQuestionMutation) ResetOption() {
	m.option = nil
	m.clearedoption = false
	m.removedoption = nil
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *SurveyQuestionMutation) ClearSurvey() {
	m.clearedsurvey = true
	m.clearedFields[surveyquestion.FieldSurveyID] = struct{}{}
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *SurveyQuestionMutation) SurveyCleared() bool {
	return m.SurveyIDCleared() || m.clearedsurvey
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *SurveyQuestionMutation) SurveyIDs() (ids []int64) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *SurveyQuestionMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// Where appends a list predicates to the SurveyQuestionMutation builder.
func (m *SurveyQuestionMutation) Where(ps ...predicate.SurveyQuestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyQuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyQuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyQuestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyQuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyQuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyQuestion).
func (m *SurveyQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyQuestionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, surveyquestion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyquestion.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, surveyquestion.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, surveyquestion.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, surveyquestion.FieldStatus)
	}
	if m.survey != nil {
		fields = append(fields, surveyquestion.FieldSurveyID)
	}
	if m.parent_id != nil {
		fields = append(fields, surveyquestion.FieldParentID)
	}
	if m.content != nil {
		fields = append(fields, surveyquestion.FieldContent)
	}
	if m._type != nil {
		fields = append(fields, surveyquestion.FieldType)
	}
	if m.sort != nil {
		fields = append(fields, surveyquestion.FieldSort)
	}
	if m.required != nil {
		fields = append(fields, surveyquestion.FieldRequired)
	}
	if m.options != nil {
		fields = append(fields, surveyquestion.FieldOptions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyquestion.FieldCreatedAt:
		return m.CreatedAt()
	case surveyquestion.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyquestion.FieldDelete:
		return m.Delete()
	case surveyquestion.FieldCreatedID:
		return m.CreatedID()
	case surveyquestion.FieldStatus:
		return m.Status()
	case surveyquestion.FieldSurveyID:
		return m.SurveyID()
	case surveyquestion.FieldParentID:
		return m.ParentID()
	case surveyquestion.FieldContent:
		return m.Content()
	case surveyquestion.FieldType:
		return m.GetType()
	case surveyquestion.FieldSort:
		return m.Sort()
	case surveyquestion.FieldRequired:
		return m.Required()
	case surveyquestion.FieldOptions:
		return m.Options()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyquestion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyquestion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyquestion.FieldDelete:
		return m.OldDelete(ctx)
	case surveyquestion.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case surveyquestion.FieldStatus:
		return m.OldStatus(ctx)
	case surveyquestion.FieldSurveyID:
		return m.OldSurveyID(ctx)
	case surveyquestion.FieldParentID:
		return m.OldParentID(ctx)
	case surveyquestion.FieldContent:
		return m.OldContent(ctx)
	case surveyquestion.FieldType:
		return m.OldType(ctx)
	case surveyquestion.FieldSort:
		return m.OldSort(ctx)
	case surveyquestion.FieldRequired:
		return m.OldRequired(ctx)
	case surveyquestion.FieldOptions:
		return m.OldOptions(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyquestion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyquestion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyquestion.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case surveyquestion.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case surveyquestion.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case surveyquestion.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyID(v)
		return nil
	case surveyquestion.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case surveyquestion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case surveyquestion.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case surveyquestion.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case surveyquestion.FieldRequired:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case surveyquestion.FieldOptions:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyQuestionMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, surveyquestion.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, surveyquestion.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, surveyquestion.FieldStatus)
	}
	if m.addparent_id != nil {
		fields = append(fields, surveyquestion.FieldParentID)
	}
	if m.addsort != nil {
		fields = append(fields, surveyquestion.FieldSort)
	}
	if m.addrequired != nil {
		fields = append(fields, surveyquestion.FieldRequired)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyquestion.FieldDelete:
		return m.AddedDelete()
	case surveyquestion.FieldCreatedID:
		return m.AddedCreatedID()
	case surveyquestion.FieldStatus:
		return m.AddedStatus()
	case surveyquestion.FieldParentID:
		return m.AddedParentID()
	case surveyquestion.FieldSort:
		return m.AddedSort()
	case surveyquestion.FieldRequired:
		return m.AddedRequired()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyquestion.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case surveyquestion.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case surveyquestion.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case surveyquestion.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case surveyquestion.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case surveyquestion.FieldRequired:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequired(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyQuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyquestion.FieldCreatedAt) {
		fields = append(fields, surveyquestion.FieldCreatedAt)
	}
	if m.FieldCleared(surveyquestion.FieldUpdatedAt) {
		fields = append(fields, surveyquestion.FieldUpdatedAt)
	}
	if m.FieldCleared(surveyquestion.FieldDelete) {
		fields = append(fields, surveyquestion.FieldDelete)
	}
	if m.FieldCleared(surveyquestion.FieldCreatedID) {
		fields = append(fields, surveyquestion.FieldCreatedID)
	}
	if m.FieldCleared(surveyquestion.FieldStatus) {
		fields = append(fields, surveyquestion.FieldStatus)
	}
	if m.FieldCleared(surveyquestion.FieldSurveyID) {
		fields = append(fields, surveyquestion.FieldSurveyID)
	}
	if m.FieldCleared(surveyquestion.FieldParentID) {
		fields = append(fields, surveyquestion.FieldParentID)
	}
	if m.FieldCleared(surveyquestion.FieldContent) {
		fields = append(fields, surveyquestion.FieldContent)
	}
	if m.FieldCleared(surveyquestion.FieldType) {
		fields = append(fields, surveyquestion.FieldType)
	}
	if m.FieldCleared(surveyquestion.FieldSort) {
		fields = append(fields, surveyquestion.FieldSort)
	}
	if m.FieldCleared(surveyquestion.FieldRequired) {
		fields = append(fields, surveyquestion.FieldRequired)
	}
	if m.FieldCleared(surveyquestion.FieldOptions) {
		fields = append(fields, surveyquestion.FieldOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyQuestionMutation) ClearField(name string) error {
	switch name {
	case surveyquestion.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case surveyquestion.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case surveyquestion.FieldDelete:
		m.ClearDelete()
		return nil
	case surveyquestion.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case surveyquestion.FieldStatus:
		m.ClearStatus()
		return nil
	case surveyquestion.FieldSurveyID:
		m.ClearSurveyID()
		return nil
	case surveyquestion.FieldParentID:
		m.ClearParentID()
		return nil
	case surveyquestion.FieldContent:
		m.ClearContent()
		return nil
	case surveyquestion.FieldType:
		m.ClearType()
		return nil
	case surveyquestion.FieldSort:
		m.ClearSort()
		return nil
	case surveyquestion.FieldRequired:
		m.ClearRequired()
		return nil
	case surveyquestion.FieldOptions:
		m.ClearOptions()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyQuestionMutation) ResetField(name string) error {
	switch name {
	case surveyquestion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyquestion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyquestion.FieldDelete:
		m.ResetDelete()
		return nil
	case surveyquestion.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case surveyquestion.FieldStatus:
		m.ResetStatus()
		return nil
	case surveyquestion.FieldSurveyID:
		m.ResetSurveyID()
		return nil
	case surveyquestion.FieldParentID:
		m.ResetParentID()
		return nil
	case surveyquestion.FieldContent:
		m.ResetContent()
		return nil
	case surveyquestion.FieldType:
		m.ResetType()
		return nil
	case surveyquestion.FieldSort:
		m.ResetSort()
		return nil
	case surveyquestion.FieldRequired:
		m.ResetRequired()
		return nil
	case surveyquestion.FieldOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.option != nil {
		edges = append(edges, surveyquestion.EdgeOption)
	}
	if m.survey != nil {
		edges = append(edges, surveyquestion.EdgeSurvey)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyquestion.EdgeOption:
		ids := make([]ent.Value, 0, len(m.option))
		for id := range m.option {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoption != nil {
		edges = append(edges, surveyquestion.EdgeOption)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case surveyquestion.EdgeOption:
		ids := make([]ent.Value, 0, len(m.removedoption))
		for id := range m.removedoption {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoption {
		edges = append(edges, surveyquestion.EdgeOption)
	}
	if m.clearedsurvey {
		edges = append(edges, surveyquestion.EdgeSurvey)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyquestion.EdgeOption:
		return m.clearedoption
	case surveyquestion.EdgeSurvey:
		return m.clearedsurvey
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyQuestionMutation) ClearEdge(name string) error {
	switch name {
	case surveyquestion.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyQuestionMutation) ResetEdge(name string) error {
	switch name {
	case surveyquestion.EdgeOption:
		m.ResetOption()
		return nil
	case surveyquestion.EdgeSurvey:
		m.ResetSurvey()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion edge %s", name)
}

// SurveyQuestionOptionsMutation represents an operation that mutates the SurveyQuestionOptions nodes in the graph.
type SurveyQuestionOptionsMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	serial          *string
	content         *string
	clearedFields   map[string]struct{}
	question        *int64
	clearedquestion bool
	done            bool
	oldValue        func(context.Context) (*SurveyQuestionOptions, error)
	predicates      []predicate.SurveyQuestionOptions
}

var _ ent.Mutation = (*SurveyQuestionOptionsMutation)(nil)

// surveyquestionoptionsOption allows management of the mutation configuration using functional options.
type surveyquestionoptionsOption func(*SurveyQuestionOptionsMutation)

// newSurveyQuestionOptionsMutation creates new mutation for the SurveyQuestionOptions entity.
func newSurveyQuestionOptionsMutation(c config, op Op, opts ...surveyquestionoptionsOption) *SurveyQuestionOptionsMutation {
	m := &SurveyQuestionOptionsMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyQuestionOptions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyQuestionOptionsID sets the ID field of the mutation.
func withSurveyQuestionOptionsID(id int64) surveyquestionoptionsOption {
	return func(m *SurveyQuestionOptionsMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyQuestionOptions
		)
		m.oldValue = func(ctx context.Context) (*SurveyQuestionOptions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyQuestionOptions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyQuestionOptions sets the old SurveyQuestionOptions of the mutation.
func withSurveyQuestionOptions(node *SurveyQuestionOptions) surveyquestionoptionsOption {
	return func(m *SurveyQuestionOptionsMutation) {
		m.oldValue = func(context.Context) (*SurveyQuestionOptions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyQuestionOptionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyQuestionOptionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyQuestionOptions entities.
func (m *SurveyQuestionOptionsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyQuestionOptionsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyQuestionOptionsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyQuestionOptions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyQuestionOptionsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyQuestionOptionsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SurveyQuestionOptionsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[surveyquestionoptions.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyQuestionOptionsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, surveyquestionoptions.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyQuestionOptionsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyQuestionOptionsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SurveyQuestionOptionsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[surveyquestionoptions.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyQuestionOptionsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, surveyquestionoptions.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SurveyQuestionOptionsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SurveyQuestionOptionsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SurveyQuestionOptionsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SurveyQuestionOptionsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SurveyQuestionOptionsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[surveyquestionoptions.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SurveyQuestionOptionsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, surveyquestionoptions.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SurveyQuestionOptionsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SurveyQuestionOptionsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SurveyQuestionOptionsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SurveyQuestionOptionsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SurveyQuestionOptionsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[surveyquestionoptions.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SurveyQuestionOptionsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, surveyquestionoptions.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SurveyQuestionOptionsMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyQuestionOptionsMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SurveyQuestionOptionsMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SurveyQuestionOptionsMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SurveyQuestionOptionsMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[surveyquestionoptions.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyQuestionOptionsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, surveyquestionoptions.FieldStatus)
}

// SetSurveyQuestionID sets the "survey_question_id" field.
func (m *SurveyQuestionOptionsMutation) SetSurveyQuestionID(i int64) {
	m.question = &i
}

// SurveyQuestionID returns the value of the "survey_question_id" field in the mutation.
func (m *SurveyQuestionOptionsMutation) SurveyQuestionID() (r int64, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyQuestionID returns the old "survey_question_id" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldSurveyQuestionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyQuestionID: %w", err)
	}
	return oldValue.SurveyQuestionID, nil
}

// ClearSurveyQuestionID clears the value of the "survey_question_id" field.
func (m *SurveyQuestionOptionsMutation) ClearSurveyQuestionID() {
	m.question = nil
	m.clearedFields[surveyquestionoptions.FieldSurveyQuestionID] = struct{}{}
}

// SurveyQuestionIDCleared returns if the "survey_question_id" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) SurveyQuestionIDCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldSurveyQuestionID]
	return ok
}

// ResetSurveyQuestionID resets all changes to the "survey_question_id" field.
func (m *SurveyQuestionOptionsMutation) ResetSurveyQuestionID() {
	m.question = nil
	delete(m.clearedFields, surveyquestionoptions.FieldSurveyQuestionID)
}

// SetSerial sets the "serial" field.
func (m *SurveyQuestionOptionsMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *SurveyQuestionOptionsMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *SurveyQuestionOptionsMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[surveyquestionoptions.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) SerialCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *SurveyQuestionOptionsMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, surveyquestionoptions.FieldSerial)
}

// SetContent sets the "content" field.
func (m *SurveyQuestionOptionsMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SurveyQuestionOptionsMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SurveyQuestionOptions entity.
// If the SurveyQuestionOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionOptionsMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *SurveyQuestionOptionsMutation) ClearContent() {
	m.content = nil
	m.clearedFields[surveyquestionoptions.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) ContentCleared() bool {
	_, ok := m.clearedFields[surveyquestionoptions.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *SurveyQuestionOptionsMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, surveyquestionoptions.FieldContent)
}

// SetQuestionID sets the "question" edge to the SurveyQuestion entity by id.
func (m *SurveyQuestionOptionsMutation) SetQuestionID(id int64) {
	m.question = &id
}

// ClearQuestion clears the "question" edge to the SurveyQuestion entity.
func (m *SurveyQuestionOptionsMutation) ClearQuestion() {
	m.clearedquestion = true
	m.clearedFields[surveyquestionoptions.FieldSurveyQuestionID] = struct{}{}
}

// QuestionCleared reports if the "question" edge to the SurveyQuestion entity was cleared.
func (m *SurveyQuestionOptionsMutation) QuestionCleared() bool {
	return m.SurveyQuestionIDCleared() || m.clearedquestion
}

// QuestionID returns the "question" edge ID in the mutation.
func (m *SurveyQuestionOptionsMutation) QuestionID() (id int64, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *SurveyQuestionOptionsMutation) QuestionIDs() (ids []int64) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *SurveyQuestionOptionsMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Where appends a list predicates to the SurveyQuestionOptionsMutation builder.
func (m *SurveyQuestionOptionsMutation) Where(ps ...predicate.SurveyQuestionOptions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyQuestionOptionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyQuestionOptionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyQuestionOptions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyQuestionOptionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyQuestionOptionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyQuestionOptions).
func (m *SurveyQuestionOptionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyQuestionOptionsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, surveyquestionoptions.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyquestionoptions.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, surveyquestionoptions.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, surveyquestionoptions.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, surveyquestionoptions.FieldStatus)
	}
	if m.question != nil {
		fields = append(fields, surveyquestionoptions.FieldSurveyQuestionID)
	}
	if m.serial != nil {
		fields = append(fields, surveyquestionoptions.FieldSerial)
	}
	if m.content != nil {
		fields = append(fields, surveyquestionoptions.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyQuestionOptionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyquestionoptions.FieldCreatedAt:
		return m.CreatedAt()
	case surveyquestionoptions.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyquestionoptions.FieldDelete:
		return m.Delete()
	case surveyquestionoptions.FieldCreatedID:
		return m.CreatedID()
	case surveyquestionoptions.FieldStatus:
		return m.Status()
	case surveyquestionoptions.FieldSurveyQuestionID:
		return m.SurveyQuestionID()
	case surveyquestionoptions.FieldSerial:
		return m.Serial()
	case surveyquestionoptions.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyQuestionOptionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyquestionoptions.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyquestionoptions.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyquestionoptions.FieldDelete:
		return m.OldDelete(ctx)
	case surveyquestionoptions.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case surveyquestionoptions.FieldStatus:
		return m.OldStatus(ctx)
	case surveyquestionoptions.FieldSurveyQuestionID:
		return m.OldSurveyQuestionID(ctx)
	case surveyquestionoptions.FieldSerial:
		return m.OldSerial(ctx)
	case surveyquestionoptions.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyQuestionOptions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyQuestionOptionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyquestionoptions.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyquestionoptions.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyquestionoptions.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case surveyquestionoptions.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case surveyquestionoptions.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case surveyquestionoptions.FieldSurveyQuestionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyQuestionID(v)
		return nil
	case surveyquestionoptions.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case surveyquestionoptions.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestionOptions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyQuestionOptionsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, surveyquestionoptions.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, surveyquestionoptions.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, surveyquestionoptions.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyQuestionOptionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyquestionoptions.FieldDelete:
		return m.AddedDelete()
	case surveyquestionoptions.FieldCreatedID:
		return m.AddedCreatedID()
	case surveyquestionoptions.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyQuestionOptionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyquestionoptions.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case surveyquestionoptions.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case surveyquestionoptions.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestionOptions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyQuestionOptionsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyquestionoptions.FieldCreatedAt) {
		fields = append(fields, surveyquestionoptions.FieldCreatedAt)
	}
	if m.FieldCleared(surveyquestionoptions.FieldUpdatedAt) {
		fields = append(fields, surveyquestionoptions.FieldUpdatedAt)
	}
	if m.FieldCleared(surveyquestionoptions.FieldDelete) {
		fields = append(fields, surveyquestionoptions.FieldDelete)
	}
	if m.FieldCleared(surveyquestionoptions.FieldCreatedID) {
		fields = append(fields, surveyquestionoptions.FieldCreatedID)
	}
	if m.FieldCleared(surveyquestionoptions.FieldStatus) {
		fields = append(fields, surveyquestionoptions.FieldStatus)
	}
	if m.FieldCleared(surveyquestionoptions.FieldSurveyQuestionID) {
		fields = append(fields, surveyquestionoptions.FieldSurveyQuestionID)
	}
	if m.FieldCleared(surveyquestionoptions.FieldSerial) {
		fields = append(fields, surveyquestionoptions.FieldSerial)
	}
	if m.FieldCleared(surveyquestionoptions.FieldContent) {
		fields = append(fields, surveyquestionoptions.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyQuestionOptionsMutation) ClearField(name string) error {
	switch name {
	case surveyquestionoptions.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case surveyquestionoptions.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case surveyquestionoptions.FieldDelete:
		m.ClearDelete()
		return nil
	case surveyquestionoptions.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case surveyquestionoptions.FieldStatus:
		m.ClearStatus()
		return nil
	case surveyquestionoptions.FieldSurveyQuestionID:
		m.ClearSurveyQuestionID()
		return nil
	case surveyquestionoptions.FieldSerial:
		m.ClearSerial()
		return nil
	case surveyquestionoptions.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestionOptions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyQuestionOptionsMutation) ResetField(name string) error {
	switch name {
	case surveyquestionoptions.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyquestionoptions.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyquestionoptions.FieldDelete:
		m.ResetDelete()
		return nil
	case surveyquestionoptions.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case surveyquestionoptions.FieldStatus:
		m.ResetStatus()
		return nil
	case surveyquestionoptions.FieldSurveyQuestionID:
		m.ResetSurveyQuestionID()
		return nil
	case surveyquestionoptions.FieldSerial:
		m.ResetSerial()
		return nil
	case surveyquestionoptions.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestionOptions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyQuestionOptionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question != nil {
		edges = append(edges, surveyquestionoptions.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyQuestionOptionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyquestionoptions.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyQuestionOptionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyQuestionOptionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion {
		edges = append(edges, surveyquestionoptions.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyQuestionOptionsMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyquestionoptions.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyQuestionOptionsMutation) ClearEdge(name string) error {
	switch name {
	case surveyquestionoptions.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestionOptions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyQuestionOptionsMutation) ResetEdge(name string) error {
	switch name {
	case surveyquestionoptions.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestionOptions edge %s", name)
}

// SurveyResponseMutation represents an operation that mutates the SurveyResponse nodes in the graph.
type SurveyResponseMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	survey_id     *int64
	addsurvey_id  *int64
	ip            *string
	_map          *string
	device        *string
	audio         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SurveyResponse, error)
	predicates    []predicate.SurveyResponse
}

var _ ent.Mutation = (*SurveyResponseMutation)(nil)

// surveyresponseOption allows management of the mutation configuration using functional options.
type surveyresponseOption func(*SurveyResponseMutation)

// newSurveyResponseMutation creates new mutation for the SurveyResponse entity.
func newSurveyResponseMutation(c config, op Op, opts ...surveyresponseOption) *SurveyResponseMutation {
	m := &SurveyResponseMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyResponse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyResponseID sets the ID field of the mutation.
func withSurveyResponseID(id int64) surveyresponseOption {
	return func(m *SurveyResponseMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyResponse
		)
		m.oldValue = func(ctx context.Context) (*SurveyResponse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyResponse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyResponse sets the old SurveyResponse of the mutation.
func withSurveyResponse(node *SurveyResponse) surveyresponseOption {
	return func(m *SurveyResponseMutation) {
		m.oldValue = func(context.Context) (*SurveyResponse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyResponseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyResponseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyResponse entities.
func (m *SurveyResponseMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyResponseMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyResponseMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyResponse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyResponseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyResponseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SurveyResponseMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[surveyresponse.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SurveyResponseMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyResponseMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, surveyresponse.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyResponseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyResponseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SurveyResponseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[surveyresponse.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SurveyResponseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyResponseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, surveyresponse.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SurveyResponseMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SurveyResponseMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SurveyResponseMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SurveyResponseMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SurveyResponseMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[surveyresponse.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SurveyResponseMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SurveyResponseMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, surveyresponse.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SurveyResponseMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SurveyResponseMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SurveyResponseMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SurveyResponseMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SurveyResponseMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[surveyresponse.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SurveyResponseMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SurveyResponseMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, surveyresponse.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SurveyResponseMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyResponseMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SurveyResponseMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SurveyResponseMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SurveyResponseMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[surveyresponse.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SurveyResponseMutation) StatusCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyResponseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, surveyresponse.FieldStatus)
}

// SetSurveyID sets the "survey_id" field.
func (m *SurveyResponseMutation) SetSurveyID(i int64) {
	m.survey_id = &i
	m.addsurvey_id = nil
}

// SurveyID returns the value of the "survey_id" field in the mutation.
func (m *SurveyResponseMutation) SurveyID() (r int64, exists bool) {
	v := m.survey_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyID returns the old "survey_id" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldSurveyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyID: %w", err)
	}
	return oldValue.SurveyID, nil
}

// AddSurveyID adds i to the "survey_id" field.
func (m *SurveyResponseMutation) AddSurveyID(i int64) {
	if m.addsurvey_id != nil {
		*m.addsurvey_id += i
	} else {
		m.addsurvey_id = &i
	}
}

// AddedSurveyID returns the value that was added to the "survey_id" field in this mutation.
func (m *SurveyResponseMutation) AddedSurveyID() (r int64, exists bool) {
	v := m.addsurvey_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSurveyID clears the value of the "survey_id" field.
func (m *SurveyResponseMutation) ClearSurveyID() {
	m.survey_id = nil
	m.addsurvey_id = nil
	m.clearedFields[surveyresponse.FieldSurveyID] = struct{}{}
}

// SurveyIDCleared returns if the "survey_id" field was cleared in this mutation.
func (m *SurveyResponseMutation) SurveyIDCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldSurveyID]
	return ok
}

// ResetSurveyID resets all changes to the "survey_id" field.
func (m *SurveyResponseMutation) ResetSurveyID() {
	m.survey_id = nil
	m.addsurvey_id = nil
	delete(m.clearedFields, surveyresponse.FieldSurveyID)
}

// SetIP sets the "ip" field.
func (m *SurveyResponseMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *SurveyResponseMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *SurveyResponseMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[surveyresponse.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *SurveyResponseMutation) IPCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *SurveyResponseMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, surveyresponse.FieldIP)
}

// SetMap sets the "map" field.
func (m *SurveyResponseMutation) SetMap(s string) {
	m._map = &s
}

// Map returns the value of the "map" field in the mutation.
func (m *SurveyResponseMutation) Map() (r string, exists bool) {
	v := m._map
	if v == nil {
		return
	}
	return *v, true
}

// OldMap returns the old "map" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldMap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMap: %w", err)
	}
	return oldValue.Map, nil
}

// ClearMap clears the value of the "map" field.
func (m *SurveyResponseMutation) ClearMap() {
	m._map = nil
	m.clearedFields[surveyresponse.FieldMap] = struct{}{}
}

// MapCleared returns if the "map" field was cleared in this mutation.
func (m *SurveyResponseMutation) MapCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldMap]
	return ok
}

// ResetMap resets all changes to the "map" field.
func (m *SurveyResponseMutation) ResetMap() {
	m._map = nil
	delete(m.clearedFields, surveyresponse.FieldMap)
}

// SetDevice sets the "device" field.
func (m *SurveyResponseMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *SurveyResponseMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *SurveyResponseMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[surveyresponse.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *SurveyResponseMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *SurveyResponseMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, surveyresponse.FieldDevice)
}

// SetAudio sets the "audio" field.
func (m *SurveyResponseMutation) SetAudio(s string) {
	m.audio = &s
}

// Audio returns the value of the "audio" field in the mutation.
func (m *SurveyResponseMutation) Audio() (r string, exists bool) {
	v := m.audio
	if v == nil {
		return
	}
	return *v, true
}

// OldAudio returns the old "audio" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldAudio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudio: %w", err)
	}
	return oldValue.Audio, nil
}

// ClearAudio clears the value of the "audio" field.
func (m *SurveyResponseMutation) ClearAudio() {
	m.audio = nil
	m.clearedFields[surveyresponse.FieldAudio] = struct{}{}
}

// AudioCleared returns if the "audio" field was cleared in this mutation.
func (m *SurveyResponseMutation) AudioCleared() bool {
	_, ok := m.clearedFields[surveyresponse.FieldAudio]
	return ok
}

// ResetAudio resets all changes to the "audio" field.
func (m *SurveyResponseMutation) ResetAudio() {
	m.audio = nil
	delete(m.clearedFields, surveyresponse.FieldAudio)
}

// Where appends a list predicates to the SurveyResponseMutation builder.
func (m *SurveyResponseMutation) Where(ps ...predicate.SurveyResponse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyResponseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyResponseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyResponse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyResponseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyResponseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyResponse).
func (m *SurveyResponseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyResponseMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, surveyresponse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyresponse.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, surveyresponse.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, surveyresponse.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, surveyresponse.FieldStatus)
	}
	if m.survey_id != nil {
		fields = append(fields, surveyresponse.FieldSurveyID)
	}
	if m.ip != nil {
		fields = append(fields, surveyresponse.FieldIP)
	}
	if m._map != nil {
		fields = append(fields, surveyresponse.FieldMap)
	}
	if m.device != nil {
		fields = append(fields, surveyresponse.FieldDevice)
	}
	if m.audio != nil {
		fields = append(fields, surveyresponse.FieldAudio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyResponseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyresponse.FieldCreatedAt:
		return m.CreatedAt()
	case surveyresponse.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyresponse.FieldDelete:
		return m.Delete()
	case surveyresponse.FieldCreatedID:
		return m.CreatedID()
	case surveyresponse.FieldStatus:
		return m.Status()
	case surveyresponse.FieldSurveyID:
		return m.SurveyID()
	case surveyresponse.FieldIP:
		return m.IP()
	case surveyresponse.FieldMap:
		return m.Map()
	case surveyresponse.FieldDevice:
		return m.Device()
	case surveyresponse.FieldAudio:
		return m.Audio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyResponseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyresponse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyresponse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyresponse.FieldDelete:
		return m.OldDelete(ctx)
	case surveyresponse.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case surveyresponse.FieldStatus:
		return m.OldStatus(ctx)
	case surveyresponse.FieldSurveyID:
		return m.OldSurveyID(ctx)
	case surveyresponse.FieldIP:
		return m.OldIP(ctx)
	case surveyresponse.FieldMap:
		return m.OldMap(ctx)
	case surveyresponse.FieldDevice:
		return m.OldDevice(ctx)
	case surveyresponse.FieldAudio:
		return m.OldAudio(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyResponse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyResponseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyresponse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyresponse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyresponse.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case surveyresponse.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case surveyresponse.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case surveyresponse.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyID(v)
		return nil
	case surveyresponse.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case surveyresponse.FieldMap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMap(v)
		return nil
	case surveyresponse.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case surveyresponse.FieldAudio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudio(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyResponseMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, surveyresponse.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, surveyresponse.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, surveyresponse.FieldStatus)
	}
	if m.addsurvey_id != nil {
		fields = append(fields, surveyresponse.FieldSurveyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyResponseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyresponse.FieldDelete:
		return m.AddedDelete()
	case surveyresponse.FieldCreatedID:
		return m.AddedCreatedID()
	case surveyresponse.FieldStatus:
		return m.AddedStatus()
	case surveyresponse.FieldSurveyID:
		return m.AddedSurveyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyResponseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyresponse.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case surveyresponse.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case surveyresponse.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case surveyresponse.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurveyID(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyResponseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyresponse.FieldCreatedAt) {
		fields = append(fields, surveyresponse.FieldCreatedAt)
	}
	if m.FieldCleared(surveyresponse.FieldUpdatedAt) {
		fields = append(fields, surveyresponse.FieldUpdatedAt)
	}
	if m.FieldCleared(surveyresponse.FieldDelete) {
		fields = append(fields, surveyresponse.FieldDelete)
	}
	if m.FieldCleared(surveyresponse.FieldCreatedID) {
		fields = append(fields, surveyresponse.FieldCreatedID)
	}
	if m.FieldCleared(surveyresponse.FieldStatus) {
		fields = append(fields, surveyresponse.FieldStatus)
	}
	if m.FieldCleared(surveyresponse.FieldSurveyID) {
		fields = append(fields, surveyresponse.FieldSurveyID)
	}
	if m.FieldCleared(surveyresponse.FieldIP) {
		fields = append(fields, surveyresponse.FieldIP)
	}
	if m.FieldCleared(surveyresponse.FieldMap) {
		fields = append(fields, surveyresponse.FieldMap)
	}
	if m.FieldCleared(surveyresponse.FieldDevice) {
		fields = append(fields, surveyresponse.FieldDevice)
	}
	if m.FieldCleared(surveyresponse.FieldAudio) {
		fields = append(fields, surveyresponse.FieldAudio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyResponseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyResponseMutation) ClearField(name string) error {
	switch name {
	case surveyresponse.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case surveyresponse.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case surveyresponse.FieldDelete:
		m.ClearDelete()
		return nil
	case surveyresponse.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case surveyresponse.FieldStatus:
		m.ClearStatus()
		return nil
	case surveyresponse.FieldSurveyID:
		m.ClearSurveyID()
		return nil
	case surveyresponse.FieldIP:
		m.ClearIP()
		return nil
	case surveyresponse.FieldMap:
		m.ClearMap()
		return nil
	case surveyresponse.FieldDevice:
		m.ClearDevice()
		return nil
	case surveyresponse.FieldAudio:
		m.ClearAudio()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyResponseMutation) ResetField(name string) error {
	switch name {
	case surveyresponse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyresponse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyresponse.FieldDelete:
		m.ResetDelete()
		return nil
	case surveyresponse.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case surveyresponse.FieldStatus:
		m.ResetStatus()
		return nil
	case surveyresponse.FieldSurveyID:
		m.ResetSurveyID()
		return nil
	case surveyresponse.FieldIP:
		m.ResetIP()
		return nil
	case surveyresponse.FieldMap:
		m.ResetMap()
		return nil
	case surveyresponse.FieldDevice:
		m.ResetDevice()
		return nil
	case surveyresponse.FieldAudio:
		m.ResetAudio()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyResponseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyResponseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyResponseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyResponseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyResponseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyResponseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyResponseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SurveyResponse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyResponseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SurveyResponse edge %s", name)
}

// SurveyResponseAnswersMutation represents an operation that mutates the SurveyResponseAnswers nodes in the graph.
type SurveyResponseAnswersMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	delete                *int64
	adddelete             *int64
	created_id            *int64
	addcreated_id         *int64
	status                *int64
	addstatus             *int64
	survey_id             *int64
	addsurvey_id          *int64
	survey_response_id    *int64
	addsurvey_response_id *int64
	survey_question_id    *int64
	addsurvey_question_id *int64
	answer_text           *string
	answer_value          *int64
	addanswer_value       *int64
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*SurveyResponseAnswers, error)
	predicates            []predicate.SurveyResponseAnswers
}

var _ ent.Mutation = (*SurveyResponseAnswersMutation)(nil)

// surveyresponseanswersOption allows management of the mutation configuration using functional options.
type surveyresponseanswersOption func(*SurveyResponseAnswersMutation)

// newSurveyResponseAnswersMutation creates new mutation for the SurveyResponseAnswers entity.
func newSurveyResponseAnswersMutation(c config, op Op, opts ...surveyresponseanswersOption) *SurveyResponseAnswersMutation {
	m := &SurveyResponseAnswersMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyResponseAnswers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyResponseAnswersID sets the ID field of the mutation.
func withSurveyResponseAnswersID(id int64) surveyresponseanswersOption {
	return func(m *SurveyResponseAnswersMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyResponseAnswers
		)
		m.oldValue = func(ctx context.Context) (*SurveyResponseAnswers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyResponseAnswers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyResponseAnswers sets the old SurveyResponseAnswers of the mutation.
func withSurveyResponseAnswers(node *SurveyResponseAnswers) surveyresponseanswersOption {
	return func(m *SurveyResponseAnswersMutation) {
		m.oldValue = func(context.Context) (*SurveyResponseAnswers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyResponseAnswersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyResponseAnswersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyResponseAnswers entities.
func (m *SurveyResponseAnswersMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyResponseAnswersMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyResponseAnswersMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyResponseAnswers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyResponseAnswersMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyResponseAnswersMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SurveyResponseAnswersMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[surveyresponseanswers.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyResponseAnswersMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, surveyresponseanswers.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyResponseAnswersMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyResponseAnswersMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SurveyResponseAnswersMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[surveyresponseanswers.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyResponseAnswersMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, surveyresponseanswers.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SurveyResponseAnswersMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SurveyResponseAnswersMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SurveyResponseAnswersMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SurveyResponseAnswersMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[surveyresponseanswers.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SurveyResponseAnswersMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, surveyresponseanswers.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SurveyResponseAnswersMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SurveyResponseAnswersMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SurveyResponseAnswersMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SurveyResponseAnswersMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[surveyresponseanswers.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SurveyResponseAnswersMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, surveyresponseanswers.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SurveyResponseAnswersMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyResponseAnswersMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SurveyResponseAnswersMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SurveyResponseAnswersMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[surveyresponseanswers.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) StatusCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyResponseAnswersMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, surveyresponseanswers.FieldStatus)
}

// SetSurveyID sets the "survey_id" field.
func (m *SurveyResponseAnswersMutation) SetSurveyID(i int64) {
	m.survey_id = &i
	m.addsurvey_id = nil
}

// SurveyID returns the value of the "survey_id" field in the mutation.
func (m *SurveyResponseAnswersMutation) SurveyID() (r int64, exists bool) {
	v := m.survey_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyID returns the old "survey_id" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldSurveyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyID: %w", err)
	}
	return oldValue.SurveyID, nil
}

// AddSurveyID adds i to the "survey_id" field.
func (m *SurveyResponseAnswersMutation) AddSurveyID(i int64) {
	if m.addsurvey_id != nil {
		*m.addsurvey_id += i
	} else {
		m.addsurvey_id = &i
	}
}

// AddedSurveyID returns the value that was added to the "survey_id" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedSurveyID() (r int64, exists bool) {
	v := m.addsurvey_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSurveyID clears the value of the "survey_id" field.
func (m *SurveyResponseAnswersMutation) ClearSurveyID() {
	m.survey_id = nil
	m.addsurvey_id = nil
	m.clearedFields[surveyresponseanswers.FieldSurveyID] = struct{}{}
}

// SurveyIDCleared returns if the "survey_id" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) SurveyIDCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldSurveyID]
	return ok
}

// ResetSurveyID resets all changes to the "survey_id" field.
func (m *SurveyResponseAnswersMutation) ResetSurveyID() {
	m.survey_id = nil
	m.addsurvey_id = nil
	delete(m.clearedFields, surveyresponseanswers.FieldSurveyID)
}

// SetSurveyResponseID sets the "survey_response_id" field.
func (m *SurveyResponseAnswersMutation) SetSurveyResponseID(i int64) {
	m.survey_response_id = &i
	m.addsurvey_response_id = nil
}

// SurveyResponseID returns the value of the "survey_response_id" field in the mutation.
func (m *SurveyResponseAnswersMutation) SurveyResponseID() (r int64, exists bool) {
	v := m.survey_response_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyResponseID returns the old "survey_response_id" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldSurveyResponseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyResponseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyResponseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyResponseID: %w", err)
	}
	return oldValue.SurveyResponseID, nil
}

// AddSurveyResponseID adds i to the "survey_response_id" field.
func (m *SurveyResponseAnswersMutation) AddSurveyResponseID(i int64) {
	if m.addsurvey_response_id != nil {
		*m.addsurvey_response_id += i
	} else {
		m.addsurvey_response_id = &i
	}
}

// AddedSurveyResponseID returns the value that was added to the "survey_response_id" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedSurveyResponseID() (r int64, exists bool) {
	v := m.addsurvey_response_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSurveyResponseID clears the value of the "survey_response_id" field.
func (m *SurveyResponseAnswersMutation) ClearSurveyResponseID() {
	m.survey_response_id = nil
	m.addsurvey_response_id = nil
	m.clearedFields[surveyresponseanswers.FieldSurveyResponseID] = struct{}{}
}

// SurveyResponseIDCleared returns if the "survey_response_id" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) SurveyResponseIDCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldSurveyResponseID]
	return ok
}

// ResetSurveyResponseID resets all changes to the "survey_response_id" field.
func (m *SurveyResponseAnswersMutation) ResetSurveyResponseID() {
	m.survey_response_id = nil
	m.addsurvey_response_id = nil
	delete(m.clearedFields, surveyresponseanswers.FieldSurveyResponseID)
}

// SetSurveyQuestionID sets the "survey_question_id" field.
func (m *SurveyResponseAnswersMutation) SetSurveyQuestionID(i int64) {
	m.survey_question_id = &i
	m.addsurvey_question_id = nil
}

// SurveyQuestionID returns the value of the "survey_question_id" field in the mutation.
func (m *SurveyResponseAnswersMutation) SurveyQuestionID() (r int64, exists bool) {
	v := m.survey_question_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyQuestionID returns the old "survey_question_id" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldSurveyQuestionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyQuestionID: %w", err)
	}
	return oldValue.SurveyQuestionID, nil
}

// AddSurveyQuestionID adds i to the "survey_question_id" field.
func (m *SurveyResponseAnswersMutation) AddSurveyQuestionID(i int64) {
	if m.addsurvey_question_id != nil {
		*m.addsurvey_question_id += i
	} else {
		m.addsurvey_question_id = &i
	}
}

// AddedSurveyQuestionID returns the value that was added to the "survey_question_id" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedSurveyQuestionID() (r int64, exists bool) {
	v := m.addsurvey_question_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSurveyQuestionID clears the value of the "survey_question_id" field.
func (m *SurveyResponseAnswersMutation) ClearSurveyQuestionID() {
	m.survey_question_id = nil
	m.addsurvey_question_id = nil
	m.clearedFields[surveyresponseanswers.FieldSurveyQuestionID] = struct{}{}
}

// SurveyQuestionIDCleared returns if the "survey_question_id" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) SurveyQuestionIDCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldSurveyQuestionID]
	return ok
}

// ResetSurveyQuestionID resets all changes to the "survey_question_id" field.
func (m *SurveyResponseAnswersMutation) ResetSurveyQuestionID() {
	m.survey_question_id = nil
	m.addsurvey_question_id = nil
	delete(m.clearedFields, surveyresponseanswers.FieldSurveyQuestionID)
}

// SetAnswerText sets the "answer_text" field.
func (m *SurveyResponseAnswersMutation) SetAnswerText(s string) {
	m.answer_text = &s
}

// AnswerText returns the value of the "answer_text" field in the mutation.
func (m *SurveyResponseAnswersMutation) AnswerText() (r string, exists bool) {
	v := m.answer_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerText returns the old "answer_text" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldAnswerText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswerText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswerText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerText: %w", err)
	}
	return oldValue.AnswerText, nil
}

// ClearAnswerText clears the value of the "answer_text" field.
func (m *SurveyResponseAnswersMutation) ClearAnswerText() {
	m.answer_text = nil
	m.clearedFields[surveyresponseanswers.FieldAnswerText] = struct{}{}
}

// AnswerTextCleared returns if the "answer_text" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) AnswerTextCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldAnswerText]
	return ok
}

// ResetAnswerText resets all changes to the "answer_text" field.
func (m *SurveyResponseAnswersMutation) ResetAnswerText() {
	m.answer_text = nil
	delete(m.clearedFields, surveyresponseanswers.FieldAnswerText)
}

// SetAnswerValue sets the "answer_value" field.
func (m *SurveyResponseAnswersMutation) SetAnswerValue(i int64) {
	m.answer_value = &i
	m.addanswer_value = nil
}

// AnswerValue returns the value of the "answer_value" field in the mutation.
func (m *SurveyResponseAnswersMutation) AnswerValue() (r int64, exists bool) {
	v := m.answer_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerValue returns the old "answer_value" field's value of the SurveyResponseAnswers entity.
// If the SurveyResponseAnswers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseAnswersMutation) OldAnswerValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswerValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswerValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerValue: %w", err)
	}
	return oldValue.AnswerValue, nil
}

// AddAnswerValue adds i to the "answer_value" field.
func (m *SurveyResponseAnswersMutation) AddAnswerValue(i int64) {
	if m.addanswer_value != nil {
		*m.addanswer_value += i
	} else {
		m.addanswer_value = &i
	}
}

// AddedAnswerValue returns the value that was added to the "answer_value" field in this mutation.
func (m *SurveyResponseAnswersMutation) AddedAnswerValue() (r int64, exists bool) {
	v := m.addanswer_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearAnswerValue clears the value of the "answer_value" field.
func (m *SurveyResponseAnswersMutation) ClearAnswerValue() {
	m.answer_value = nil
	m.addanswer_value = nil
	m.clearedFields[surveyresponseanswers.FieldAnswerValue] = struct{}{}
}

// AnswerValueCleared returns if the "answer_value" field was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) AnswerValueCleared() bool {
	_, ok := m.clearedFields[surveyresponseanswers.FieldAnswerValue]
	return ok
}

// ResetAnswerValue resets all changes to the "answer_value" field.
func (m *SurveyResponseAnswersMutation) ResetAnswerValue() {
	m.answer_value = nil
	m.addanswer_value = nil
	delete(m.clearedFields, surveyresponseanswers.FieldAnswerValue)
}

// Where appends a list predicates to the SurveyResponseAnswersMutation builder.
func (m *SurveyResponseAnswersMutation) Where(ps ...predicate.SurveyResponseAnswers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyResponseAnswersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyResponseAnswersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyResponseAnswers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyResponseAnswersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyResponseAnswersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyResponseAnswers).
func (m *SurveyResponseAnswersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyResponseAnswersMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, surveyresponseanswers.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyresponseanswers.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, surveyresponseanswers.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, surveyresponseanswers.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, surveyresponseanswers.FieldStatus)
	}
	if m.survey_id != nil {
		fields = append(fields, surveyresponseanswers.FieldSurveyID)
	}
	if m.survey_response_id != nil {
		fields = append(fields, surveyresponseanswers.FieldSurveyResponseID)
	}
	if m.survey_question_id != nil {
		fields = append(fields, surveyresponseanswers.FieldSurveyQuestionID)
	}
	if m.answer_text != nil {
		fields = append(fields, surveyresponseanswers.FieldAnswerText)
	}
	if m.answer_value != nil {
		fields = append(fields, surveyresponseanswers.FieldAnswerValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyResponseAnswersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyresponseanswers.FieldCreatedAt:
		return m.CreatedAt()
	case surveyresponseanswers.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyresponseanswers.FieldDelete:
		return m.Delete()
	case surveyresponseanswers.FieldCreatedID:
		return m.CreatedID()
	case surveyresponseanswers.FieldStatus:
		return m.Status()
	case surveyresponseanswers.FieldSurveyID:
		return m.SurveyID()
	case surveyresponseanswers.FieldSurveyResponseID:
		return m.SurveyResponseID()
	case surveyresponseanswers.FieldSurveyQuestionID:
		return m.SurveyQuestionID()
	case surveyresponseanswers.FieldAnswerText:
		return m.AnswerText()
	case surveyresponseanswers.FieldAnswerValue:
		return m.AnswerValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyResponseAnswersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyresponseanswers.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyresponseanswers.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyresponseanswers.FieldDelete:
		return m.OldDelete(ctx)
	case surveyresponseanswers.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case surveyresponseanswers.FieldStatus:
		return m.OldStatus(ctx)
	case surveyresponseanswers.FieldSurveyID:
		return m.OldSurveyID(ctx)
	case surveyresponseanswers.FieldSurveyResponseID:
		return m.OldSurveyResponseID(ctx)
	case surveyresponseanswers.FieldSurveyQuestionID:
		return m.OldSurveyQuestionID(ctx)
	case surveyresponseanswers.FieldAnswerText:
		return m.OldAnswerText(ctx)
	case surveyresponseanswers.FieldAnswerValue:
		return m.OldAnswerValue(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyResponseAnswers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyResponseAnswersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyresponseanswers.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyresponseanswers.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyresponseanswers.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case surveyresponseanswers.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case surveyresponseanswers.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case surveyresponseanswers.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyID(v)
		return nil
	case surveyresponseanswers.FieldSurveyResponseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyResponseID(v)
		return nil
	case surveyresponseanswers.FieldSurveyQuestionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyQuestionID(v)
		return nil
	case surveyresponseanswers.FieldAnswerText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerText(v)
		return nil
	case surveyresponseanswers.FieldAnswerValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerValue(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyResponseAnswers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyResponseAnswersMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, surveyresponseanswers.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, surveyresponseanswers.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, surveyresponseanswers.FieldStatus)
	}
	if m.addsurvey_id != nil {
		fields = append(fields, surveyresponseanswers.FieldSurveyID)
	}
	if m.addsurvey_response_id != nil {
		fields = append(fields, surveyresponseanswers.FieldSurveyResponseID)
	}
	if m.addsurvey_question_id != nil {
		fields = append(fields, surveyresponseanswers.FieldSurveyQuestionID)
	}
	if m.addanswer_value != nil {
		fields = append(fields, surveyresponseanswers.FieldAnswerValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyResponseAnswersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyresponseanswers.FieldDelete:
		return m.AddedDelete()
	case surveyresponseanswers.FieldCreatedID:
		return m.AddedCreatedID()
	case surveyresponseanswers.FieldStatus:
		return m.AddedStatus()
	case surveyresponseanswers.FieldSurveyID:
		return m.AddedSurveyID()
	case surveyresponseanswers.FieldSurveyResponseID:
		return m.AddedSurveyResponseID()
	case surveyresponseanswers.FieldSurveyQuestionID:
		return m.AddedSurveyQuestionID()
	case surveyresponseanswers.FieldAnswerValue:
		return m.AddedAnswerValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyResponseAnswersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyresponseanswers.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case surveyresponseanswers.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case surveyresponseanswers.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case surveyresponseanswers.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurveyID(v)
		return nil
	case surveyresponseanswers.FieldSurveyResponseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurveyResponseID(v)
		return nil
	case surveyresponseanswers.FieldSurveyQuestionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurveyQuestionID(v)
		return nil
	case surveyresponseanswers.FieldAnswerValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnswerValue(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyResponseAnswers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyResponseAnswersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyresponseanswers.FieldCreatedAt) {
		fields = append(fields, surveyresponseanswers.FieldCreatedAt)
	}
	if m.FieldCleared(surveyresponseanswers.FieldUpdatedAt) {
		fields = append(fields, surveyresponseanswers.FieldUpdatedAt)
	}
	if m.FieldCleared(surveyresponseanswers.FieldDelete) {
		fields = append(fields, surveyresponseanswers.FieldDelete)
	}
	if m.FieldCleared(surveyresponseanswers.FieldCreatedID) {
		fields = append(fields, surveyresponseanswers.FieldCreatedID)
	}
	if m.FieldCleared(surveyresponseanswers.FieldStatus) {
		fields = append(fields, surveyresponseanswers.FieldStatus)
	}
	if m.FieldCleared(surveyresponseanswers.FieldSurveyID) {
		fields = append(fields, surveyresponseanswers.FieldSurveyID)
	}
	if m.FieldCleared(surveyresponseanswers.FieldSurveyResponseID) {
		fields = append(fields, surveyresponseanswers.FieldSurveyResponseID)
	}
	if m.FieldCleared(surveyresponseanswers.FieldSurveyQuestionID) {
		fields = append(fields, surveyresponseanswers.FieldSurveyQuestionID)
	}
	if m.FieldCleared(surveyresponseanswers.FieldAnswerText) {
		fields = append(fields, surveyresponseanswers.FieldAnswerText)
	}
	if m.FieldCleared(surveyresponseanswers.FieldAnswerValue) {
		fields = append(fields, surveyresponseanswers.FieldAnswerValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyResponseAnswersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyResponseAnswersMutation) ClearField(name string) error {
	switch name {
	case surveyresponseanswers.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case surveyresponseanswers.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case surveyresponseanswers.FieldDelete:
		m.ClearDelete()
		return nil
	case surveyresponseanswers.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case surveyresponseanswers.FieldStatus:
		m.ClearStatus()
		return nil
	case surveyresponseanswers.FieldSurveyID:
		m.ClearSurveyID()
		return nil
	case surveyresponseanswers.FieldSurveyResponseID:
		m.ClearSurveyResponseID()
		return nil
	case surveyresponseanswers.FieldSurveyQuestionID:
		m.ClearSurveyQuestionID()
		return nil
	case surveyresponseanswers.FieldAnswerText:
		m.ClearAnswerText()
		return nil
	case surveyresponseanswers.FieldAnswerValue:
		m.ClearAnswerValue()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponseAnswers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyResponseAnswersMutation) ResetField(name string) error {
	switch name {
	case surveyresponseanswers.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyresponseanswers.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyresponseanswers.FieldDelete:
		m.ResetDelete()
		return nil
	case surveyresponseanswers.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case surveyresponseanswers.FieldStatus:
		m.ResetStatus()
		return nil
	case surveyresponseanswers.FieldSurveyID:
		m.ResetSurveyID()
		return nil
	case surveyresponseanswers.FieldSurveyResponseID:
		m.ResetSurveyResponseID()
		return nil
	case surveyresponseanswers.FieldSurveyQuestionID:
		m.ResetSurveyQuestionID()
		return nil
	case surveyresponseanswers.FieldAnswerText:
		m.ResetAnswerText()
		return nil
	case surveyresponseanswers.FieldAnswerValue:
		m.ResetAnswerValue()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponseAnswers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyResponseAnswersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyResponseAnswersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyResponseAnswersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyResponseAnswersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyResponseAnswersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyResponseAnswersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyResponseAnswersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SurveyResponseAnswers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyResponseAnswersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SurveyResponseAnswers edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	user_id       *int64
	adduser_id    *int64
	token         *string
	_type         *int64
	add_type      *int64
	source        *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[token.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, token.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[token.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, token.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *TokenMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *TokenMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *TokenMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *TokenMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *TokenMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[token.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *TokenMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[token.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *TokenMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, token.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *TokenMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *TokenMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *TokenMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *TokenMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *TokenMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[token.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *TokenMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[token.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *TokenMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, token.FieldCreatedID)
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TokenMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TokenMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetType sets the "type" field.
func (m *TokenMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TokenMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *TokenMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TokenMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *TokenMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[token.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TokenMutation) TypeCleared() bool {
	_, ok := m.clearedFields[token.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TokenMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, token.FieldType)
}

// SetSource sets the "source" field.
func (m *TokenMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TokenMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TokenMutation) ResetSource() {
	m.source = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TokenMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, token.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.user_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m._type != nil {
		fields = append(fields, token.FieldType)
	}
	if m.source != nil {
		fields = append(fields, token.FieldSource)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldDelete:
		return m.Delete()
	case token.FieldCreatedID:
		return m.CreatedID()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldToken:
		return m.Token()
	case token.FieldType:
		return m.GetType()
	case token.FieldSource:
		return m.Source()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldDelete:
		return m.OldDelete(ctx)
	case token.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldType:
		return m.OldType(ctx)
	case token.FieldSource:
		return m.OldSource(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case token.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case token.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, token.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.adduser_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.add_type != nil {
		fields = append(fields, token.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldDelete:
		return m.AddedDelete()
	case token.FieldCreatedID:
		return m.AddedCreatedID()
	case token.FieldUserID:
		return m.AddedUserID()
	case token.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case token.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case token.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldCreatedAt) {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.FieldCleared(token.FieldUpdatedAt) {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.FieldCleared(token.FieldDelete) {
		fields = append(fields, token.FieldDelete)
	}
	if m.FieldCleared(token.FieldCreatedID) {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.FieldCleared(token.FieldType) {
		fields = append(fields, token.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case token.FieldDelete:
		m.ClearDelete()
		return nil
	case token.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case token.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldDelete:
		m.ResetDelete()
		return nil
	case token.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldType:
		m.ResetType()
		return nil
	case token.FieldSource:
		m.ResetSource()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete              *int64
	adddelete           *int64
	created_id          *int64
	addcreated_id       *int64
	status              *int64
	addstatus           *int64
	mobile              *string
	name                *string
	gender              *int64
	addgender           *int64
	username            *string
	password            *string
	functions           *[]string
	appendfunctions     []string
	job_time            *int64
	addjob_time         *int64
	detail              *string
	side_mode           *string
	base_color          *string
	active_color        *string
	email               *string
	wecom               *string
	organization        *string
	default_venue_id    *int64
	adddefault_venue_id *int64
	avatar              *string
	birthday            *time.Time
	clearedFields       map[string]struct{}
	token               *int64
	clearedtoken        bool
	roles               map[int64]struct{}
	removedroles        map[int64]struct{}
	clearedroles        bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *UserMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *UserMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *UserMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *UserMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *UserMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[user.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *UserMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[user.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *UserMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, user.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *UserMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *UserMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *UserMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *UserMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *UserMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[user.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *UserMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *UserMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, user.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *UserMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *UserMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFunctions sets the "functions" field.
func (m *UserMutation) SetFunctions(s []string) {
	m.functions = &s
	m.appendfunctions = nil
}

// Functions returns the value of the "functions" field in the mutation.
func (m *UserMutation) Functions() (r []string, exists bool) {
	v := m.functions
	if v == nil {
		return
	}
	return *v, true
}

// OldFunctions returns the old "functions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFunctions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunctions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunctions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunctions: %w", err)
	}
	return oldValue.Functions, nil
}

// AppendFunctions adds s to the "functions" field.
func (m *UserMutation) AppendFunctions(s []string) {
	m.appendfunctions = append(m.appendfunctions, s...)
}

// AppendedFunctions returns the list of values that were appended to the "functions" field in this mutation.
func (m *UserMutation) AppendedFunctions() ([]string, bool) {
	if len(m.appendfunctions) == 0 {
		return nil, false
	}
	return m.appendfunctions, true
}

// ResetFunctions resets all changes to the "functions" field.
func (m *UserMutation) ResetFunctions() {
	m.functions = nil
	m.appendfunctions = nil
}

// SetJobTime sets the "job_time" field.
func (m *UserMutation) SetJobTime(i int64) {
	m.job_time = &i
	m.addjob_time = nil
}

// JobTime returns the value of the "job_time" field in the mutation.
func (m *UserMutation) JobTime() (r int64, exists bool) {
	v := m.job_time
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTime returns the old "job_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJobTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTime: %w", err)
	}
	return oldValue.JobTime, nil
}

// AddJobTime adds i to the "job_time" field.
func (m *UserMutation) AddJobTime(i int64) {
	if m.addjob_time != nil {
		*m.addjob_time += i
	} else {
		m.addjob_time = &i
	}
}

// AddedJobTime returns the value that was added to the "job_time" field in this mutation.
func (m *UserMutation) AddedJobTime() (r int64, exists bool) {
	v := m.addjob_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearJobTime clears the value of the "job_time" field.
func (m *UserMutation) ClearJobTime() {
	m.job_time = nil
	m.addjob_time = nil
	m.clearedFields[user.FieldJobTime] = struct{}{}
}

// JobTimeCleared returns if the "job_time" field was cleared in this mutation.
func (m *UserMutation) JobTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldJobTime]
	return ok
}

// ResetJobTime resets all changes to the "job_time" field.
func (m *UserMutation) ResetJobTime() {
	m.job_time = nil
	m.addjob_time = nil
	delete(m.clearedFields, user.FieldJobTime)
}

// SetDetail sets the "detail" field.
func (m *UserMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *UserMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *UserMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[user.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *UserMutation) DetailCleared() bool {
	_, ok := m.clearedFields[user.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *UserMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, user.FieldDetail)
}

// SetSideMode sets the "side_mode" field.
func (m *UserMutation) SetSideMode(s string) {
	m.side_mode = &s
}

// SideMode returns the value of the "side_mode" field in the mutation.
func (m *UserMutation) SideMode() (r string, exists bool) {
	v := m.side_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSideMode returns the old "side_mode" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSideMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSideMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSideMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSideMode: %w", err)
	}
	return oldValue.SideMode, nil
}

// ClearSideMode clears the value of the "side_mode" field.
func (m *UserMutation) ClearSideMode() {
	m.side_mode = nil
	m.clearedFields[user.FieldSideMode] = struct{}{}
}

// SideModeCleared returns if the "side_mode" field was cleared in this mutation.
func (m *UserMutation) SideModeCleared() bool {
	_, ok := m.clearedFields[user.FieldSideMode]
	return ok
}

// ResetSideMode resets all changes to the "side_mode" field.
func (m *UserMutation) ResetSideMode() {
	m.side_mode = nil
	delete(m.clearedFields, user.FieldSideMode)
}

// SetBaseColor sets the "base_color" field.
func (m *UserMutation) SetBaseColor(s string) {
	m.base_color = &s
}

// BaseColor returns the value of the "base_color" field in the mutation.
func (m *UserMutation) BaseColor() (r string, exists bool) {
	v := m.base_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseColor returns the old "base_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBaseColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseColor: %w", err)
	}
	return oldValue.BaseColor, nil
}

// ClearBaseColor clears the value of the "base_color" field.
func (m *UserMutation) ClearBaseColor() {
	m.base_color = nil
	m.clearedFields[user.FieldBaseColor] = struct{}{}
}

// BaseColorCleared returns if the "base_color" field was cleared in this mutation.
func (m *UserMutation) BaseColorCleared() bool {
	_, ok := m.clearedFields[user.FieldBaseColor]
	return ok
}

// ResetBaseColor resets all changes to the "base_color" field.
func (m *UserMutation) ResetBaseColor() {
	m.base_color = nil
	delete(m.clearedFields, user.FieldBaseColor)
}

// SetActiveColor sets the "active_color" field.
func (m *UserMutation) SetActiveColor(s string) {
	m.active_color = &s
}

// ActiveColor returns the value of the "active_color" field in the mutation.
func (m *UserMutation) ActiveColor() (r string, exists bool) {
	v := m.active_color
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveColor returns the old "active_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActiveColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveColor: %w", err)
	}
	return oldValue.ActiveColor, nil
}

// ClearActiveColor clears the value of the "active_color" field.
func (m *UserMutation) ClearActiveColor() {
	m.active_color = nil
	m.clearedFields[user.FieldActiveColor] = struct{}{}
}

// ActiveColorCleared returns if the "active_color" field was cleared in this mutation.
func (m *UserMutation) ActiveColorCleared() bool {
	_, ok := m.clearedFields[user.FieldActiveColor]
	return ok
}

// ResetActiveColor resets all changes to the "active_color" field.
func (m *UserMutation) ResetActiveColor() {
	m.active_color = nil
	delete(m.clearedFields, user.FieldActiveColor)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *UserMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *UserMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *UserMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[user.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *UserMutation) WecomCleared() bool {
	_, ok := m.clearedFields[user.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *UserMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, user.FieldWecom)
}

// SetOrganization sets the "organization" field.
func (m *UserMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *UserMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *UserMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[user.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *UserMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[user.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, user.FieldOrganization)
}

// SetDefaultVenueID sets the "default_venue_id" field.
func (m *UserMutation) SetDefaultVenueID(i int64) {
	m.default_venue_id = &i
	m.adddefault_venue_id = nil
}

// DefaultVenueID returns the value of the "default_venue_id" field in the mutation.
func (m *UserMutation) DefaultVenueID() (r int64, exists bool) {
	v := m.default_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVenueID returns the old "default_venue_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDefaultVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVenueID: %w", err)
	}
	return oldValue.DefaultVenueID, nil
}

// AddDefaultVenueID adds i to the "default_venue_id" field.
func (m *UserMutation) AddDefaultVenueID(i int64) {
	if m.adddefault_venue_id != nil {
		*m.adddefault_venue_id += i
	} else {
		m.adddefault_venue_id = &i
	}
}

// AddedDefaultVenueID returns the value that was added to the "default_venue_id" field in this mutation.
func (m *UserMutation) AddedDefaultVenueID() (r int64, exists bool) {
	v := m.adddefault_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultVenueID clears the value of the "default_venue_id" field.
func (m *UserMutation) ClearDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	m.clearedFields[user.FieldDefaultVenueID] = struct{}{}
}

// DefaultVenueIDCleared returns if the "default_venue_id" field was cleared in this mutation.
func (m *UserMutation) DefaultVenueIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDefaultVenueID]
	return ok
}

// ResetDefaultVenueID resets all changes to the "default_venue_id" field.
func (m *UserMutation) ResetDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	delete(m.clearedFields, user.FieldDefaultVenueID)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *UserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[user.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *UserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, user.FieldBirthday)
}

// SetTokenID sets the "token" edge to the Token entity by id.
func (m *UserMutation) SetTokenID(id int64) {
	m.token = &id
}

// ClearToken clears the "token" edge to the Token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *UserMutation) TokenID() (id int64, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TokenIDs() (ids []int64) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, user.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.functions != nil {
		fields = append(fields, user.FieldFunctions)
	}
	if m.job_time != nil {
		fields = append(fields, user.FieldJobTime)
	}
	if m.detail != nil {
		fields = append(fields, user.FieldDetail)
	}
	if m.side_mode != nil {
		fields = append(fields, user.FieldSideMode)
	}
	if m.base_color != nil {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.active_color != nil {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, user.FieldWecom)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganization)
	}
	if m.default_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDelete:
		return m.Delete()
	case user.FieldCreatedID:
		return m.CreatedID()
	case user.FieldStatus:
		return m.Status()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldName:
		return m.Name()
	case user.FieldGender:
		return m.Gender()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFunctions:
		return m.Functions()
	case user.FieldJobTime:
		return m.JobTime()
	case user.FieldDetail:
		return m.Detail()
	case user.FieldSideMode:
		return m.SideMode()
	case user.FieldBaseColor:
		return m.BaseColor()
	case user.FieldActiveColor:
		return m.ActiveColor()
	case user.FieldEmail:
		return m.Email()
	case user.FieldWecom:
		return m.Wecom()
	case user.FieldOrganization:
		return m.Organization()
	case user.FieldDefaultVenueID:
		return m.DefaultVenueID()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldBirthday:
		return m.Birthday()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDelete:
		return m.OldDelete(ctx)
	case user.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFunctions:
		return m.OldFunctions(ctx)
	case user.FieldJobTime:
		return m.OldJobTime(ctx)
	case user.FieldDetail:
		return m.OldDetail(ctx)
	case user.FieldSideMode:
		return m.OldSideMode(ctx)
	case user.FieldBaseColor:
		return m.OldBaseColor(ctx)
	case user.FieldActiveColor:
		return m.OldActiveColor(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldWecom:
		return m.OldWecom(ctx)
	case user.FieldOrganization:
		return m.OldOrganization(ctx)
	case user.FieldDefaultVenueID:
		return m.OldDefaultVenueID(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case user.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFunctions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunctions(v)
		return nil
	case user.FieldJobTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTime(v)
		return nil
	case user.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case user.FieldSideMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSideMode(v)
		return nil
	case user.FieldBaseColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseColor(v)
		return nil
	case user.FieldActiveColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveColor(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case user.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVenueID(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, user.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.addjob_time != nil {
		fields = append(fields, user.FieldJobTime)
	}
	if m.adddefault_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDelete:
		return m.AddedDelete()
	case user.FieldCreatedID:
		return m.AddedCreatedID()
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldJobTime:
		return m.AddedJobTime()
	case user.FieldDefaultVenueID:
		return m.AddedDefaultVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case user.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldJobTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJobTime(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDelete) {
		fields = append(fields, user.FieldDelete)
	}
	if m.FieldCleared(user.FieldCreatedID) {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldJobTime) {
		fields = append(fields, user.FieldJobTime)
	}
	if m.FieldCleared(user.FieldDetail) {
		fields = append(fields, user.FieldDetail)
	}
	if m.FieldCleared(user.FieldSideMode) {
		fields = append(fields, user.FieldSideMode)
	}
	if m.FieldCleared(user.FieldBaseColor) {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.FieldCleared(user.FieldActiveColor) {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldWecom) {
		fields = append(fields, user.FieldWecom)
	}
	if m.FieldCleared(user.FieldOrganization) {
		fields = append(fields, user.FieldOrganization)
	}
	if m.FieldCleared(user.FieldDefaultVenueID) {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldBirthday) {
		fields = append(fields, user.FieldBirthday)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDelete:
		m.ClearDelete()
		return nil
	case user.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldJobTime:
		m.ClearJobTime()
		return nil
	case user.FieldDetail:
		m.ClearDetail()
		return nil
	case user.FieldSideMode:
		m.ClearSideMode()
		return nil
	case user.FieldBaseColor:
		m.ClearBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ClearActiveColor()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldWecom:
		m.ClearWecom()
		return nil
	case user.FieldOrganization:
		m.ClearOrganization()
		return nil
	case user.FieldDefaultVenueID:
		m.ClearDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldBirthday:
		m.ClearBirthday()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDelete:
		m.ResetDelete()
		return nil
	case user.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFunctions:
		m.ResetFunctions()
		return nil
	case user.FieldJobTime:
		m.ResetJobTime()
		return nil
	case user.FieldDetail:
		m.ResetDetail()
		return nil
	case user.FieldSideMode:
		m.ResetSideMode()
		return nil
	case user.FieldBaseColor:
		m.ResetBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ResetActiveColor()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldWecom:
		m.ResetWecom()
		return nil
	case user.FieldOrganization:
		m.ResetOrganization()
		return nil
	case user.FieldDefaultVenueID:
		m.ResetDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeToken:
		return m.clearedtoken
	case user.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ResetToken()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
